<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>如何在EDK II中编写应用程序</title>
    <url>/2020/05/25/EDK2-new-app/</url>
    <content><![CDATA[<p>EDK2的开发一般分为驱动与应用的开发，本文介绍如何在EDK2中开发应用程序。官方的教程请参考：<a href="https://github.com/tianocore/tianocore.github.io/wiki/Getting-Started-Writing-Simple-Application" target="_blank" rel="noopener">Getting Started Writing Simple Application</a>。</p>
<h3 id="如何编写C文件"><a href="#如何编写C文件" class="headerlink" title="如何编写C文件"></a>如何编写C文件</h3><p><code>https://github.com/tianocore/tianocore.github.io/wiki/Getting-Started-Writing-MyHelloWorld.c</code></p>
<h3 id="如何编写inf文件"><a href="#如何编写inf文件" class="headerlink" title="如何编写inf文件"></a>如何编写inf文件</h3><h4 id="如何生成GUID"><a href="#如何生成GUID" class="headerlink" title="如何生成GUID"></a>如何生成GUID</h4><p>通过<a href="https://www.guidgen.com/" target="_blank" rel="noopener">guidgen网站</a>生成GUID。</p>
]]></content>
      <categories>
        <category>EDK2</category>
      </categories>
      <tags>
        <tag>EDK2</tag>
        <tag>EDKii</tag>
        <tag>EDK II</tag>
      </tags>
  </entry>
  <entry>
    <title>android逆向学习计划</title>
    <url>/2020/07/22/android-reverse-engineering-plan/</url>
    <content><![CDATA[<p>参考<a href="https://zhuanlan.zhihu.com/p/101396731" target="_blank" rel="noopener">如何系统的学习安卓逆向</a>,制定如下学习计划。</p>
<h2 id="一-安卓逆向基础（建议1周）"><a href="#一-安卓逆向基础（建议1周）" class="headerlink" title="一. 安卓逆向基础（建议1周）"></a>一. 安卓逆向基础（建议1周）</h2><ol>
<li>学习安卓逆向第一步必须先把环境搭建好，这是你学习安卓逆向的开始，环境搭建好后表示正式迈入安卓逆向。在环境安装的工程中会遇到很多细节上的问题，针对这些坑可以去看看使用教程，或者看看网课老师的教程操作都可以。</li>
<li>第二步就是要了解我们要分析的是什么文件，很多0基础的都不知道安卓逆向分析的什么文件。我们要分析的是应用程序或者安装包（就是.apk文件），了解apk是怎么生成的以及如何安装到我们的手机里面，apk是怎么运行的，也是我们探讨的内容。</li>
<li>第三步如何逆向分析.apk文件，掌握apk反编译及回编译，完成这个操作使用的工具是apktool。<a id="more"></a>

</li>
</ol>
<h2 id="二-Java层逆向（建议3周）"><a href="#二-Java层逆向（建议3周）" class="headerlink" title="二. Java层逆向（建议3周）"></a>二. Java层逆向（建议3周）</h2><ol>
<li>掌握Java语法基础，达到能看懂Java代码。</li>
<li>了解smali语法，能看懂smali代码。</li>
<li>掌握逆向分析apk中常用的方法和技巧。</li>
</ol>
<h2 id="三-Native层逆向（建议4周）"><a href="#三-Native层逆向（建议4周）" class="headerlink" title="三. Native层逆向（建议4周）"></a>三. Native层逆向（建议4周）</h2><ol>
<li>了解安卓操作系统和四大组件。</li>
<li>了解NDK开发流程，自己编写案例练习。</li>
<li>掌握常用ARM汇编指令，达到能看懂ARM汇编指令。</li>
<li>掌握ida工具的使用，熟练使用ida进行各种操作。</li>
</ol>
<h2 id="四-APK保护策略（建议1周）"><a href="#四-APK保护策略（建议1周）" class="headerlink" title="四. APK保护策略（建议1周）"></a>四. APK保护策略（建议1周）</h2><ol>
<li>了解Java代码混淆、资源混淆。</li>
<li>掌握签名验证、文件校验、模拟器检测。</li>
<li>本地验证、网络验证。</li>
<li>案例练习。</li>
</ol>
<h2 id="五-反调试与反-反调试（建议1周）"><a href="#五-反调试与反-反调试（建议1周）" class="headerlink" title="五. 反调试与反-反调试（建议1周）"></a>五. 反调试与反-反调试（建议1周）</h2><ol>
<li>掌握常用反调试方法及过反调试技巧，比如关键文件检测、调试端口检测、进程名称检测、防附加、轮训检测TracerPid值、时间检测、信号检测等反调试。</li>
<li>掌握IDA过反调试思路。</li>
<li>案例练习。</li>
</ol>
<h2 id="六-HOOK框架（建议2周）"><a href="#六-HOOK框架（建议2周）" class="headerlink" title="六. HOOK框架（建议2周）"></a>六. HOOK框架（建议2周）</h2><ol>
<li>掌握HOOK插件开发。</li>
<li>掌握Xposed、Substrate、Fridad等框架。</li>
<li>案例练习。</li>
</ol>
<h2 id="七-常见加密算法（建议2周）"><a href="#七-常见加密算法（建议2周）" class="headerlink" title="七. 常见加密算法（建议2周）"></a>七. 常见加密算法（建议2周）</h2><ol>
<li>掌握编码算法、消息摘要算法、对称加密算法（Java加密与解密的艺术）。</li>
<li>掌握非对称加密算法、数字签名算法。</li>
</ol>
<h2 id="八-协议加解密分析（建议4周）"><a href="#八-协议加解密分析（建议4周）" class="headerlink" title="八. 协议加解密分析（建议4周）"></a>八. 协议加解密分析（建议4周）</h2><ol>
<li>了解客户端与服务器如何进行交互的（OSI模型、TCP/IP模型）。</li>
<li>掌握常用的抓包工具及环境配置，HTTP协议与HTTPS安全协议，数字证书、SSL证书检测（计算机网络与通信、信息安全工程师）。</li>
<li>案例练习。</li>
</ol>
<h2 id="九-文件结构（建议2周）"><a href="#九-文件结构（建议2周）" class="headerlink" title="九. 文件结构（建议2周）"></a>九. 文件结构（建议2周）</h2><ol>
<li>掌握DEX、ELF、XML、ARSC等文件结构。</li>
<li>自编写文件解析工具。</li>
</ol>
<h2 id="十-系统源码分析（建议2周）"><a href="#十-系统源码分析（建议2周）" class="headerlink" title="十. 系统源码分析（建议2周）"></a>十. 系统源码分析（建议2周）</h2><ol>
<li>了解安卓操作系统启动流程、Zygote启动流程。</li>
<li>掌握Dalvik虚拟机、ART虚拟机、SO加载流程。</li>
</ol>
<h2 id="十一-加固与脱壳（建议4周）"><a href="#十一-加固与脱壳（建议4周）" class="headerlink" title="十一. 加固与脱壳（建议4周）"></a>十一. 加固与脱壳（建议4周）</h2><ol>
<li>了解Dex文件整体加密、Dex代码抽取加密。</li>
<li>了解so文件整体加密、函数加密、区段加密、加壳、混淆。</li>
<li>分析通用脱壳机的实现原理及应用场景。</li>
<li>了解主流加固特点及对应的脱壳技巧。</li>
</ol>
<h2 id="十二-学习方法"><a href="#十二-学习方法" class="headerlink" title="十二. 学习方法"></a>十二. 学习方法</h2><ol>
<li>看一遍教程后自己实战操作，养成做笔记的习惯。</li>
<li>注重基础，一定要把Java层和Native层搞懂。</li>
<li>学习中不要纠结细节，要学会抓大放小。</li>
<li>学完后自己画脑图，回顾学习的过程中那些不理解在花时间去看，此过程就是查漏补缺。</li>
</ol>
]]></content>
      <categories>
        <category>android逆向</category>
      </categories>
      <tags>
        <tag>android逆向</tag>
      </tags>
  </entry>
  <entry>
    <title>c/c++ 变量</title>
    <url>/2020/12/04/c-cpp-variable/</url>
    <content><![CDATA[<h3 id="关于c-c-变量溢出问题"><a href="#关于c-c-变量溢出问题" class="headerlink" title="关于c/c++变量溢出问题"></a>关于c/c++变量溢出问题</h3><ol>
<li><p>无符号变量溢出<br>无符号变量没有负数，只有正数。例如：unsigned char var = 280;其实际值为280%256=24。</p>
</li>
<li><p>有符号变量溢出<br>有符号数最高位表示符号位，1为负数，0为正数。例如：unsigned char var = 128,溢出了，最高为1，所以为负数，根据负数为反码+1，可以知道实际值为-128。</p>
<a id="more"></a>

</li>
</ol>
<h3 id="关于c-c-变量，不同平台或者架构int变量size不一样问题"><a href="#关于c-c-变量，不同平台或者架构int变量size不一样问题" class="headerlink" title="关于c/c++变量，不同平台或者架构int变量size不一样问题"></a>关于c/c++变量，不同平台或者架构int变量size不一样问题</h3><ol>
<li>在不同的平台或者编译器中，标准类型int所占用的size可能不一样，为了解决这给问题，C99中引入了<code>stdint.h</code>头文件来定义指定宽度类型。如:<code>std::int8_t</code>、<code>std::uint8_t</code>、<code>std::uint16_t</code>、<code>std::int32_t</code>、<code>std::int64_t</code>等。所以在C中可以通过引入<code>stdint.h</code>来使用这些类型。在C++11中，这些类型被纳入到<code>cstdint</code>头文件中。<br>使用如上头文件的时候，需要注意，可能某些平台并不支持，所以在代码可移植性方面较差。</li>
<li>c++标准定义的类型(实际使用中，推荐用该方法，因为他是安全的)<br>std::int_fast8_t<br>std::int_fast32_t<br>std::uint_fast16_t<br>std::int_least8_t<br>std::uint_least16_t<br>std::int_least_64_t</li>
</ol>
<h3 id="constexpr关键字"><a href="#constexpr关键字" class="headerlink" title="constexpr关键字"></a>constexpr关键字</h3><p><code>constexpr</code>关键字是C++11中引入的关键字，用于申明常量的值需要在编译时确定。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> a =<span class="number">25</span>; <span class="comment">// ok</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> sum&#123;<span class="number">4</span>+<span class="number">11</span>&#125;; <span class="comment">// ok</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> var; <span class="comment">// not okay</span></span><br></pre></td></tr></table></figure>

<h3 id="关于全局变量与局部变量"><a href="#关于全局变量与局部变量" class="headerlink" title="关于全局变量与局部变量"></a>关于全局变量与局部变量</h3><ol>
<li>同名局部变量在其作用域内会屏蔽全局变量，也就是局部变量会被优先使用<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> Var = <span class="number">9</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Var = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Var = "</span> &lt;&lt; Var &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
上面的程序运行结果为<code>Var = 2</code>。在C++中可以通过范围运算符<code>::</code>来指定使用全局变量。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> Var = <span class="number">9</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Var = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Var = "</span> &lt;&lt; ::Var &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
上面的程序运行结果为<code>Var = 9</code>。</li>
</ol>
<h3 id="关于C-17中的inline-variables"><a href="#关于C-17中的inline-variables" class="headerlink" title="关于C++17中的inline variables"></a>关于C++17中的<code>inline variables</code></h3><p>c++17中为变量引入了<code>inline variable</code>类型。<code>inline variable</code>允许在多个文件中定义，而不会违反编译检查规则，当在多个文件中定义了同名的<code>inline variable</code>时，编译器在编译时将所有的同名<code>inline variables</code>实例化为一个变量。请看如下例子中的使用：<br>constants.h:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONSTANTS_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONSTANTS_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> constants &#123;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">constexpr</span> <span class="keyword">double</span> pi &#123;<span class="number">3.14159</span>&#125;;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">constexpr</span> <span class="keyword">double</span> avogadro &#123;<span class="number">6.022141</span>&#125;;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">constexpr</span> <span class="keyword">double</span> gravity &#123;<span class="number">9.2</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>main.cpp:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"constants.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter a radius: "</span>;</span><br><span class="line">    <span class="keyword">int</span> radius;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; radius;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The circumference is: "</span> &lt;&lt; <span class="number">2.0</span> * radius * constants::pi &lt;&lt; <span class="string">'\n'</span>; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="c-中别名与typedef"><a href="#c-中别名与typedef" class="headerlink" title="c++中别名与typedef"></a>c++中别名与typedef</h3><p>typedef 用法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// typedef 定义的别名应该在后面加上`_t`，表面它是一个类型而不是变量</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Score_t;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span>* Pint_t;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">float</span> <span class="keyword">distance_t</span>;</span><br></pre></td></tr></table></figure>
<p>别名的用法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">score_t</span> = <span class="keyword">int</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">distance_t</span> = <span class="keyword">float</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">pairlist_t</span> = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">int</span>&gt;&gt;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
      </tags>
  </entry>
  <entry>
    <title>android simpleperf工具使用入门</title>
    <url>/2020/05/15/android-simpleperf/</url>
    <content><![CDATA[<p>&emsp;&emsp;Simpleperf 是一个通用的命令行 CPU 性能剖析工具，在Android NDK中已经自带了。需要注意的是，如果自带的simpleperf不能使用，就需要在适配当前Android设备的源码中编译了。simpleperf的源码在AOSP的system/extras/simpleperf下，其中doc目录详细介绍了如何使用该工具。</p>
<a id="more"></a>

<h2 id="在源码中编译simpleperf"><a href="#在源码中编译simpleperf" class="headerlink" title="在源码中编译simpleperf"></a>在源码中编译simpleperf</h2><p>&emsp;&emsp;可以通过如下命令在Andorid设备的源码中编译simpleperf:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> build/envsetup.sh</span><br><span class="line">lunch aosp_arm64-eng</span><br><span class="line">make simpleperf -j32</span><br></pre></td></tr></table></figure>
<p>最后将会生成out/target/product/xxx/system/xbin/simpleperf，这就是需要push到Android设备的simpleperf。</p>
<h3 id="push-simpleperf"><a href="#push-simpleperf" class="headerlink" title="push simpleperf"></a>push simpleperf</h3><p>&emsp;&emsp;在push之前需要需要保证Android设备具有root权限，一般通过adb root选项进行提权。然后通过如下命令将simpleperf push到设备。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">adb root</span><br><span class="line">adb shell mkdir /data/bin</span><br><span class="line">adb push &lt;编译出来的simpleperf&gt; /data/bin/simpleperf</span><br><span class="line">adb shell setenforce 0</span><br></pre></td></tr></table></figure>
<p>进行了上述步骤后，就可以在设备中使用simpleperf了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">adb shell /data/bin/simpleperf --version</span><br><span class="line"><span class="comment"># simpleperf I command.cpp:131] Simpleperf version 1.c65e6065befd</span></span><br><span class="line"><span class="comment">#</span></span><br></pre></td></tr></table></figure>

<h2 id="simpleperf使用介绍"><a href="#simpleperf使用介绍" class="headerlink" title="simpleperf使用介绍"></a>simpleperf使用介绍</h2><p>&emsp;&emsp;simpleperf的record命令用于转储已需要分析的进程的样本。 每个样本可以包含诸如样本生成时间，自上一个样本以来的事件数，线程的程序计数器，线程的调用链之类的信息。后续的分析步骤都是基于这个样本信息来分析的。</p>
<h3 id="采集样本数据"><a href="#采集样本数据" class="headerlink" title="采集样本数据"></a>采集样本数据</h3><p>首先确认需要分析的进程。比如分析当前cpu占用最高的进程。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">top -m 5 <span class="comment"># 得到执行的进程名字</span></span><br><span class="line"><span class="comment">## 根据pidof得到需要分析的进程id号</span></span><br><span class="line">pidof &lt;进程名&gt;</span><br></pre></td></tr></table></figure>
<p>得到进程id后就可以进行数据采集了。如果使用simpleperf的recod命令请参<a href="https://android.googlesource.com/platform/system/extras/+/refs/heads/master/simpleperf/doc/executable_commands_reference.md" target="_blank" rel="noopener">考官方文档</a>中的<code>The record command</code>小节。<br>如下的命令记录进行号为11961的record：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/data/bin/simpleperf record -p 11961 -o /sdcard/perf_11961.data --duration 360</span><br></pre></td></tr></table></figure>
<p>结果保存在/sdcard/perf_11961.data,记录持续时间为360秒。这里只记录了默认的<code>cpu-cycles</code>event，如果需要记录更加多的event需要指定-e参数。通过<code>simpleperf list</code>命令查看支持哪些events。</p>
<h3 id="查看特定进程调用的动态库"><a href="#查看特定进程调用的动态库" class="headerlink" title="查看特定进程调用的动态库"></a>查看特定进程调用的动态库</h3><p>通过report命令可以查看这种report数据：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./simpleperf report --sort dso -i /sdcard/perf_11961.data</span><br><span class="line">simpleperf W dso.cpp:361] failed to <span class="built_in">read</span> symbols from [vdso]: File not found</span><br><span class="line">Cmdline: /data/bin/simpleperf record -p 11961 -o /sdcard/perf_11961.data --duration 360</span><br><span class="line">Arch: arm64</span><br><span class="line">Event: cpu-cycles (<span class="built_in">type</span> 0, config 0)</span><br><span class="line">Samples: 649</span><br><span class="line">Event count: 136430910</span><br><span class="line"></span><br><span class="line">Overhead  Shared Object</span><br><span class="line">57.91%    [kernel.kallsyms]</span><br><span class="line">20.03%    /system/lib64/libart.so</span><br><span class="line">9.43%     /system/lib64/libandroidfw.so</span><br><span class="line">5.05%     /system/framework/arm64/boot-framework.oat</span><br><span class="line">3.58%     /system/lib64/libc.so</span><br><span class="line">1.67%     /system/framework/arm64/boot-core-oj.oat</span><br><span class="line">0.89%     /system/lib64/libbinder.so</span><br><span class="line">0.39%     /system/lib64/libc++.so</span><br><span class="line">0.38%     /system/lib64/libopenjdk.so</span><br><span class="line">0.27%     /system/lib64/libz.so</span><br><span class="line">0.15%     /system/lib64/libandroid_runtime.so</span><br><span class="line">0.13%     [vdso]</span><br><span class="line">0.07%     /system/framework/arm64/boot-core-libart.oat</span><br><span class="line">0.05%     /system/lib64/libutils.so</span><br></pre></td></tr></table></figure>

<h3 id="查看函数调用关系"><a href="#查看函数调用关系" class="headerlink" title="查看函数调用关系"></a>查看函数调用关系</h3><p>simpleperf report还可以导出函数调用关系,–symfs可以指定符号表的目录。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/data/bin/simpleperf report -g  -i /sdcard/perf_19357.data --symfs . &gt; /sdcard/g_19357.dat</span><br></pre></td></tr></table></figure>

<h4 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h4><ol>
<li><a href="https://blog.csdn.net/zhuyong006/article/details/103112571" target="_blank" rel="noopener">https://blog.csdn.net/zhuyong006/article/details/103112571</a></li>
<li><a href="https://developer.android.com/ndk/guides/simpleperf" target="_blank" rel="noopener">https://developer.android.com/ndk/guides/simpleperf</a></li>
</ol>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>c++对char类型指针的处理</title>
    <url>/2020/12/24/cpp-char-point/</url>
    <content><![CDATA[<p>本文主要记录c++对char类型指针的处理。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> Name[]&#123;<span class="string">"Lucy"</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; Name &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *mName&#123;<span class="string">"Lucy"</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; mName &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>上面程序的输出是一样的，但是编译器对<code>Name</code>与<code>mName</code>的处理是有区别的。<code>Name</code>是普通的字符数组，是一个局部变量，生命周期跟普通的变量一样。<code>mName</code>的生命周期存在于整个文件，跟<code>static</code>变量类似。看下面的例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Lucy"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面函数并不会导致返回未知，因为返回的变量类似于<code>static</code>变量。再看下面的例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> Name[]&#123;<span class="string">"Lucy"</span>&#125;;</span><br><span class="line">    <span class="keyword">return</span> Name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面函数的返回时未知的，它返回的是一个野指针，因为<code>Name</code>是局部变量，在函数返回时就被释放了，所以返回未知。</p>
<h3 id="c-对cosnt-char-类型的优化"><a href="#c-对cosnt-char-类型的优化" class="headerlink" title="c++对cosnt char* 类型的优化"></a>c++对cosnt char* 类型的优化</h3><p>如果两个<code>const char *</code>指向相同内容的字符串，那么编译器可能会优化为两个指针指向同一个位置，看下面的例子。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *NameA&#123;<span class="string">"Name"</span>&#125;;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *NameB&#123;<span class="string">"Name"</span>&#125;;</span><br><span class="line"></span><br><span class="line">    NameA[<span class="number">1</span>] = <span class="string">'A'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; NameA &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; NameB &lt;&lt;  <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; (<span class="keyword">long</span>)NameA &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; (<span class="keyword">long</span>)NameB &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行后可以看到<code>NameA</code>与<code>NameB</code>的值是相同的，也就是他们指向同一个内存地址。</p>
]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
      </tags>
  </entry>
  <entry>
    <title>c++ 内存管理</title>
    <url>/2020/12/23/cpp-new-delete/</url>
    <content><![CDATA[<p>本文主要记录下c/c++中使用堆内存的注意事项。</p>
<h3 id="堆内存使用完后，指针设置为nullptr"><a href="#堆内存使用完后，指针设置为nullptr" class="headerlink" title="堆内存使用完后，指针设置为nullptr"></a>堆内存使用完后，指针设置为nullptr</h3><p>在使用完new(malloc)的内存后，应该习惯在释放完该内存后，将指针设置为<code>nullptr</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">*p = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line">p = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure>

<p>###应该关注new的内存是否分配成功<br>在申请内存过程中，有极小概率的情况申请分配内存失败，应该处理出现申请分配内存失败的情况。有一种简便的方法用于申请内存时，如果申请失败，那么返回一个空指针，这各方法时通过在new与类型之间加入常量<code>std::nothrow</code>实现的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = <span class="keyword">new</span> (<span class="built_in">std</span>::nothrow) <span class="keyword">int</span>;</span><br><span class="line"><span class="keyword">if</span> (!p) &#123;</span><br><span class="line">    <span class="comment">// 错误处理</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"No enough memory!"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp_ofstream_ifstream</title>
    <url>/2020/08/20/cpp-ofstream-ifstream/</url>
    <content><![CDATA[<p>ofstream是从内存到硬盘，ifstream是从硬盘到内存，其实所谓的流缓冲就是内存空间。<br>在C++中，有一个stream这个类，所有的I/O都以这个“流”类为基础的，包括我们要认识的文件I/O。<br>stream这个类有两个重要的运算符：<br>1、插入器(&lt;&lt;)<br>向流输出数据。比如说系统有一个默认的标准输出流(cout)，一般情况下就是指的显示器，所以，cout&lt;&lt;”Write Stdout”&lt;&lt;’\n’;就表示把字符串”Write Stdout”和换行字符(‘\n’)输出到标准输出流。<br>2、析取器(&gt;&gt;)<br>从流中输入数据。比如说系统有一个默认的标准输入流(cin)，一般情况下就是指的键盘，所以，cin&gt;&gt;x;就表示从标准输入流中读取一个指定类型的数据。<br>在C++中，对文件的操作是通过stream的子类fstream(file stream)来实现的，所以，要用这种方式操作文件，就必须加入头文件fstream.h。</p>
<p>特别提出的是，fstream有两个子类：ifstream(input file stream)和ofstream(outpu file stream)，ifstream默认以输入方式打开文件，ofstream默认以输出方式打开文件。</p>
]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
      </tags>
  </entry>
  <entry>
    <title>脱机安装cx_oracle</title>
    <url>/2020/12/15/cx-oracle-install/</url>
    <content><![CDATA[<p>当服务器没有root权限的时候，安装某些Python模块就不方便了，该文章记录下，当没有root权限时，本地安装Python第三方模块的临时办法，以<code>cx_Oracle</code>模块进行说明。<br>###准备工作<br>在安装<code>cx_Oracle</code>之前，服务器是需要安装<code>basic packages</code>与<code>Development and Runtime packages</code>，下载网址为：<a href="https://www.oracle.com/database/technologies/instant-client/linux-x86-64-downloads.html。" target="_blank" rel="noopener">https://www.oracle.com/database/technologies/instant-client/linux-x86-64-downloads.html。</a><br>当前本地环境为<code>python 2.7</code>，选择了如下的包：<br>instantclient-basic-linux.x64-11.2.0.4.0.zip<br>instantclient-sdk-linux.x64-11.2.0.4.0.zip</p>
<a id="more"></a>

<h3 id="安装oracle-instantclient"><a href="#安装oracle-instantclient" class="headerlink" title="安装oracle instantclient"></a>安装oracle instantclient</h3><p>将上一步骤的zip包解压。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir -p ~/tools/oracle</span><br><span class="line">cp instantclient-basic-linux.x64-11.2.0.4.0.zip ~/tools/oracle</span><br><span class="line">cp instantclient-sdk-linux.x64-11.2.0.4.0.zip ~/tools/oracle</span><br><span class="line"><span class="built_in">cd</span> ~/tools/oracle</span><br><span class="line">unzip instantclient-sdk-linux.x64-11.2.0.4.0.zip</span><br><span class="line">unzip instantclient-basic-linux.x64-11.2.0.4.0.zip</span><br><span class="line"><span class="built_in">cd</span> instantclient_11_2</span><br><span class="line">cp -R sdk/* ./</span><br><span class="line">cp -R ./sdk/include/* .</span><br><span class="line">ln -s libclntsh.so.12.1 libclntsh.so</span><br><span class="line">ln -s libocci.so.12.1 libocci.so</span><br><span class="line"><span class="built_in">export</span> ORACLE_HOME=~/tools/oralce/instantclient_11_2/</span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=<span class="variable">$LD_LIBRARY_PATH</span>:<span class="variable">$ORACLE_HOME</span></span><br></pre></td></tr></table></figure>

<p>###编译安装cx_Oracle<br>先需要下载cx_Oracle的源码，从<a href="https://github.com/oracle/python-cx_Oracle" target="_blank" rel="noopener">github网站</a>,可以下载到。由于我使用的<code>python 2.7</code>根据介绍，使用<a href="https://github.com/oracle/python-cx_Oracle/archive/5.3.zip" target="_blank" rel="noopener">5.x的版本</a>。<br>下载后安装步骤如下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">unzip python-cx_Oracle-5.3.zip</span><br><span class="line"><span class="built_in">cd</span> python-cx_Oracle-5.3</span><br><span class="line">python setup.py build</span><br><span class="line">mkdir install</span><br><span class="line"><span class="built_in">export</span> PYTHONPATH=<span class="variable">$PYTHONPATH</span>:~/tools/oralce/python-cx_Oracle-5.3/install</span><br><span class="line">python setup.py install --prefix=~/tools/oralce/python-cx_Oracle-5.3/install</span><br><span class="line"><span class="comment">## 注意上个步骤会报错，执行下面的步骤继续</span></span><br><span class="line"><span class="built_in">export</span> PYTHONPATH=<span class="variable">$PYTHONPATH</span>:~/tools/oralce/python-cx_Oracle-5.3/installlib/python2.7/site-packages/</span><br><span class="line">python setup.py install --prefix=~/tools/oralce/python-cx_Oracle-5.3/install</span><br></pre></td></tr></table></figure>
<p>按照上面的步骤就可以安装成功了。</p>
<p>###cx_Oracle使用<br>因为当前不是在系统路径安装的，所以重新开一个窗口会导致<code>import cx_Oracle</code>失败，需要编写一个脚本来进行环境变量的设置，然后加入到<code>.bashrc</code>中也是可以的。<br>下面是设置环境变量的脚本(<code>envsetup.sh</code>):</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> ORACLE_HOME=~/tools/oralce/instantclient_11_2/</span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=<span class="variable">$LD_LIBRARY_PATH</span>:<span class="variable">$ORACLE_HOME</span></span><br><span class="line"><span class="built_in">export</span> PYTHONPATH=<span class="variable">$PYTHONPATH</span>:~/tools/oralce/python-cx_Oracle-5.3/installlib/python2.7/site-packages/</span><br></pre></td></tr></table></figure>
<p>上面的步骤执行完后，就可以在Python中导入<code>cx_Oracle</code>模块了。</p>
<p>###总结<br>其实该方法可以推广到其他模块的安装，当你需要在本地临时验证时。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol>
<li><a href="https://www.cnblogs.com/doctormo/p/12059738.html" target="_blank" rel="noopener">https://www.cnblogs.com/doctormo/p/12059738.html</a></li>
<li><a href="https://blog.csdn.net/yuan_lo/article/details/48289317" target="_blank" rel="noopener">https://blog.csdn.net/yuan_lo/article/details/48289317</a></li>
<li><a href="https://stackoverflow.com/questions/25885467/cx-oracle-pip-install-fails-oci-h-no-such-file-or-directory" target="_blank" rel="noopener">https://stackoverflow.com/questions/25885467/cx-oracle-pip-install-fails-oci-h-no-such-file-or-directory</a></li>
</ol>
]]></content>
      <categories>
        <category>python</category>
        <category>oracle</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>dexfile 文件格式</title>
    <url>/2020/07/24/dexfile/</url>
    <content><![CDATA[<p>Android APK中，最终java文件会被编译为classes.dex文件。如果要分析APK就得了解dex文件的格式。<br>dex文件的格式在AOSP源码的<code>dalvik/libdex/DexFile.h</code>有定义。</p>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Andorid SDK 下载</title>
    <url>/2020/07/29/downloadAndroidSDK/</url>
    <content><![CDATA[<h2 id="下载commandlinetools"><a href="#下载commandlinetools" class="headerlink" title="下载commandlinetools"></a>下载commandlinetools</h2><p>下载地址：<a href="https://developer.android.com/studio" target="_blank" rel="noopener">https://developer.android.com/studio</a> 点击进去可以查看<code>Command line tools only</code>小节</p>
<h2 id="解压安装commandlinetools"><a href="#解压安装commandlinetools" class="headerlink" title="解压安装commandlinetools"></a>解压安装commandlinetools</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cp commandlinetools-linux-6609375_latest.zip ~/</span><br><span class="line">mkdir -p ~/Android/platform-tools</span><br><span class="line">unzip  ~/Android/commandlinetools-linux-6609375_latest.zip -d ~/Android/platform-tools/</span><br><span class="line"><span class="built_in">export</span> ANDROID_HOME=~/Android</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>$:<span class="variable">$ANDROID_HOME</span>/cmdline-tools/tools/bin</span><br></pre></td></tr></table></figure>

<p>##安装android sdk<br>安装sdk请参考官方文档：<code>https://developer.android.com/studio/command-line/sdkmanager</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sdkmanager <span class="string">"platform-tools"</span> <span class="string">"platforms;android-28"</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>keepalived 安装与使用</title>
    <url>/2021/01/12/keepalived/</url>
    <content><![CDATA[<p>&emsp;&emsp;Keepalived 是一个基于VRRP协议来实现的LVS服务高可用方案，可以利用其来避免单点故障。一个LVS服务会有2台服务器运行Keepalived，一台为主服务器（MASTER），一台为备份服务器（BACKUP），但是对外表现为一个虚拟IP（VIP），主服务器会发送特定的消息给备份服务器，当备份服务器收不到这个消息的时候，即主服务器宕机的时候，备份服务器就会接管虚拟IP，继续提供服务，从而保证了高可用性。说白了就是如果客户端在访问服务端时，如果服务端出了问题，可以及时自动的切换到另外一个服务器，而客户端感知不到，客户端通过VIP来访问服务端。</p>
<a id="more"></a>
<h3 id="keepalived-工作原理"><a href="#keepalived-工作原理" class="headerlink" title="keepalived 工作原理"></a>keepalived 工作原理</h3><p>下图是keepalived的工作原理图：<br><img src="/images/keepalived-vrrp-network.png" alt="keepalived工作原理">。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. LB1服务器：192.168.10.111 master</span><br><span class="line">2. LB2服务器：192.168.10.112 backup</span><br><span class="line">3. VIP: 192.168.10.121</span><br></pre></td></tr></table></figure>
<ol>
<li>keepalived在LB1与LB2上安装，一个为master一个为backup。图中LB1为master，所以刚开始的时候LB1服务器虚拟出VIP 192.168.10.121，当客户端访问192.168.10.121的时候实际访问的就是LB1服务器。</li>
<li>keepavlied是基于VRRP协议的，关于什么是VRRP协议可以自行<a href="https://www.jianshu.com/p/7410507d57c3" target="_blank" rel="noopener">搜索</a>。根据VRRP协议可以知道，由于当前master为LB1，所以LB1会做如下工作：</li>
</ol>
<ul>
<li>定时发送VRRP通告报文(时间间隔为Advertisement_Interval)</li>
<li>使用虚拟MAC地址响应VIP的ARP请求</li>
<li>转发目的MAC地址为虚拟MAC地址的IP报文</li>
<li>抢占模式下，如果收到比自己优先级大的VRRP报文，或者跟自己优先级相等，且本地接口IP地址小于源端接口IP地址时，则转变为Backup状态</li>
<li>收到Shutdown（关闭）消息后，则立即转变为Initialize状态</li>
</ul>
<ol start="3">
<li>LB2当前为backup,backup机器会接受master发送的VRRP通告报文，判断master是否正常。如果一定时间间隔没有收到VRRP通告报文，即Master_Down_Interval（Master_Down_Interval = 3* Advertisement_Interval + Skew_time）超时，则判断为Master故障。backup的工作如下：</li>
</ol>
<ul>
<li>接收Master发送的VRRP通告报文，判断Master是否正常</li>
<li>对虚拟IP的ARP请求不做响应</li>
<li>丢弃目的MAC地址为虚拟路由器MAC地址的IP报文</li>
<li>丢弃目的IP地址为VIP地址的IP报文</li>
<li>如果收到优先级比自己高，或与自己相等的VRRP报文，则重置Master_Down_Interval定时器（不进一步比较IP地址）</li>
<li>如果收到优先级比自己小的VPPR报文，且优先级为0时，（表示原Master设备声明不参与该VRRP组了），定时器时间设置为Skew_time（偏移时间，Skew_time= (256 - priority)/256）</li>
<li>如果收到优先级比自己小的VPPR报文，且优先级不为0时，丢弃该报文，立即转变为Master状态</li>
<li>Master_Down_Interval定时器超时，立即转变为Master状态</li>
<li>收到Shutdown（关闭）消息后，则立即转变为Initialize状态</li>
</ul>
<ol start="4">
<li>当LB1上的web1服务出现问题时，此时可以降低LB1的优先级，或者停止LB1上的keepalived进程，从而将master转移到LB2上。此时客户端访问192.168.10.121即访问的LB2服务器。</li>
</ol>
<h3 id="keepalived-安装"><a href="#keepalived-安装" class="headerlink" title="keepalived 安装"></a>keepalived 安装</h3><p>测试环境为<code>CentOS Linux release 7.4.1708</code>,下面时安装命令。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install -y keepalived</span><br></pre></td></tr></table></figure>
<p>配置文件路径为:/etc/keepalived/keepalived.conf<br>默认log就是syslog，/var/log/messages</p>
<h3 id="keepalived配置"><a href="#keepalived配置" class="headerlink" title="keepalived配置"></a>keepalived配置</h3><ol>
<li>master配置<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">! Configuration File for keepalived</span><br><span class="line"></span><br><span class="line">global_defs &#123;</span><br><span class="line">    router_id keep_231</span><br><span class="line">    script_user root</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_script check_sample_alive &#123;</span><br><span class="line">    script &quot;&#x2F;check_sample.sh&quot;</span><br><span class="line">    interval 2</span><br><span class="line">    weight -10</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    state MASTER</span><br><span class="line">    interface eth0</span><br><span class="line">    virtual_router_id 51</span><br><span class="line">    priority 101</span><br><span class="line">    advert_int 1</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 1111</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    track_script &#123;</span><br><span class="line">        check_sample_alive</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # 单播模式</span><br><span class="line">    unicast_src_ip 192.168.10.111</span><br><span class="line">    unicast_peer &#123;</span><br><span class="line">        192.168.10.112</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        192.168.10.121</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
关于配置文件的配置可以自行搜索，讲一下几个关键的。<code>script_user</code>表示执行<code>check_sample_alive</code>的用户。同时也可以在<code>global_defs</code>section定义<code>enable_script_security</code>来增加安全性，但是需要你的脚本所在位置所属为root的用户与用户组。也即是要<code>chown root:root /check_sample.sh</code><br>下面时<code>check_sample.sh</code>脚本的内容：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">active=`ps -ef | grep <span class="string">"python sample.py"</span> | grep -v <span class="string">"grep"</span> | wc -l`</span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$active</span> -eq 0 ];<span class="keyword">then</span></span><br><span class="line">  sleep 3</span><br><span class="line">  <span class="keyword">if</span> [ `ps -ef | grep <span class="string">"python sample.py"</span> | grep -v <span class="string">"grep"</span> | wc -l` -eq 0 ];<span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"sample.py died"</span></span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"sample.py is running..."</span></span><br></pre></td></tr></table></figure></li>
<li>backup配置<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">! Configuration File for keepalived</span><br><span class="line"></span><br><span class="line">global_defs &#123;</span><br><span class="line">    router_id keep_232</span><br><span class="line">    script_user root</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_script check_sample_alive &#123;</span><br><span class="line">    script &quot;&#x2F;check_sample.sh&quot;</span><br><span class="line">    interval 2</span><br><span class="line">    weight 10</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    state BACKUP</span><br><span class="line">    interface eth0</span><br><span class="line">    virtual_router_id 51</span><br><span class="line">    priority 90</span><br><span class="line">    advert_int 1</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 1111</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    track_script &#123;</span><br><span class="line">        check_sample_alive</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    unicast_src_ip 192.168.10.112</span><br><span class="line">    unicast_peer &#123;</span><br><span class="line">        192.168.10.111</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        192.168.10.121</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="测试web服务器脚本"><a href="#测试web服务器脚本" class="headerlink" title="测试web服务器脚本"></a>测试web服务器脚本</h3><p>因为要测试master与backup是否能够正常切换，所以使用了python的wsgi脚本来简单的测试配置是否正确。下面是web服务器代码(sample.py)，它通过wsgi接口简单的返回当前主机的ip。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">from</span> wsgiref.simple_server <span class="keyword">import</span> make_server</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">simple_app</span><span class="params">(environ, start_response)</span>:</span></span><br><span class="line">    <span class="comment">#setup_testing_defaults(environ)</span></span><br><span class="line"></span><br><span class="line">    status = <span class="string">'200 OK'</span></span><br><span class="line">    headers = [(<span class="string">'Content-type'</span>, <span class="string">'text/plain'</span>)]</span><br><span class="line"></span><br><span class="line">    start_response(status, headers)</span><br><span class="line"></span><br><span class="line">    ip = socket.gethostbyname(socket.gethostname())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ip</span><br><span class="line"></span><br><span class="line">httpd = make_server(<span class="string">''</span>, <span class="number">7000</span>, simple_app)</span><br><span class="line"></span><br><span class="line">httpd.serve_forever()</span><br></pre></td></tr></table></figure>

<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>先在LB1与LB2服务器上启动keepalived。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">service keepalived start</span><br></pre></td></tr></table></figure>
<p>然后在LB1与LB2服务器上以后台方式启动sample.py。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python sample.py &amp;</span><br></pre></td></tr></table></figure>
<p>通过在浏览器中访问: <code>http://192.168.10.121:7000</code>可以看到浏览器会返回当前master的IP:<code>192.168.10.111</code>。然后将192.168.10.111上的sample.py进程杀掉，再访问<code>http://192.168.10.121:7000</code>可以看到浏览器会返回当前master的IP:<code>192.168.10.112</code>。可见切换成功。</p>
<p>参考：</p>
<ol>
<li>入门：<a href="https://zhuanlan.zhihu.com/p/143295216" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/143295216</a></li>
<li>入门：<a href="https://zhuanlan.zhihu.com/p/43971218" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/43971218</a></li>
<li>VRRP原理：<a href="https://www.jianshu.com/p/214f89298646" target="_blank" rel="noopener">https://www.jianshu.com/p/214f89298646</a></li>
<li>优先级设置：<a href="https://www.cnblogs.com/arjenlee/p/9258188.html" target="_blank" rel="noopener">https://www.cnblogs.com/arjenlee/p/9258188.html</a></li>
</ol>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>keepalived</tag>
      </tags>
  </entry>
  <entry>
    <title>如何在kernel中获取当前进程的信息</title>
    <url>/2020/08/18/kernel-get-process-info/</url>
    <content><![CDATA[<p>&emsp;&emsp;在kernel中有时候可能需要根据当前进行的某些信息进行逻辑处理，本文就是介绍如果在kernel中如果获取当前进程的信息。<br>&emsp;&emsp;在kernel中关于进程信息的一个重要的结构体就是task_struct，定义如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> &#123;</span></span><br><span class="line"><span class="comment">//这个是进程的运行时状态，-1代表不可运行，0代表可运行，&gt;0代表已停止。</span></span><br><span class="line"> <span class="keyword">volatile</span> <span class="keyword">long</span> state;</span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">flags是进程当前的状态标志，具体的如：</span></span><br><span class="line"><span class="comment">0x00000002表示进程正在被创建；</span></span><br><span class="line"><span class="comment">0x00000004表示进程正准备退出；</span></span><br><span class="line"><span class="comment">0x00000040 表示此进程被fork出，但是并没有执行exec；</span></span><br><span class="line"><span class="comment">0x00000400表示此进程由于其他进程发送相关信号而被杀死 。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">int</span> flags;</span><br><span class="line"><span class="comment">//表示此进程的运行优先级</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">int</span> rt_priority;</span><br><span class="line"><span class="comment">//这里出现了list_head结构体，详情请参考</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">tasks</span>;</span></span><br><span class="line"><span class="comment">//这里出现了mm_struct 结构体，该结构体记录了进程内存使用的相关情况，详情请参考</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span>;</span></span><br><span class="line"><span class="comment">/* 接下来是进程的一些状态参数*/</span></span><br><span class="line"> <span class="keyword">int</span> exit_state;</span><br><span class="line"> <span class="keyword">int</span> exit_code, exit_signal;</span><br><span class="line"><span class="comment">//这个是进程号</span></span><br><span class="line"> <span class="keyword">pid_t</span> pid;</span><br><span class="line"><span class="comment">//这个是进程组号</span></span><br><span class="line"> <span class="keyword">pid_t</span> tgid;</span><br><span class="line"><span class="comment">//real_parent是该进程的”亲生父亲“，不管其是否被“寄养”。</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">real_parent</span>;</span></span><br><span class="line"><span class="comment">//parent是该进程现在的父进程，有可能是”继父“</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">parent</span>;</span></span><br><span class="line"><span class="comment">//这里children指的是该进程孩子的链表，可以得到所有孩子的进程描述符，但是需使用list_for_each和list_entry，list_entry其实直接使用了container_of，详情请参考</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">children</span>;</span></span><br><span class="line"><span class="comment">//同理，sibling该进程兄弟的链表，也就是其父亲的所有孩子的链表。用法与children相似。</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">sibling</span>;</span></span><br><span class="line"><span class="comment">//这个是主线程的进程描述符，也许你会奇怪，为什么线程用进程描述符表示，因为linux并没有单独实现线程的相关结构体，只是用一个进程来代替线程，然后对其做一些特殊的处理。</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">group_leader</span>;</span></span><br><span class="line"><span class="comment">//这个是该进程所有线程的链表。</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">thread_group</span>;</span></span><br><span class="line"><span class="comment">//顾名思义，这个是该进程使用cpu时间的信息，utime是在用户态下执行的时间，stime是在内核态下执行的时间。</span></span><br><span class="line"> <span class="keyword">cputime_t</span> utime, stime;</span><br><span class="line"><span class="comment">//下面的是启动的时间，只是时间基准不一样。</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">start_time</span>;</span> </span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">real_start_time</span>;</span></span><br><span class="line"><span class="comment">//comm是保存该进程名字的字符数组，长度最长为15，因为TASK_COMM_LEN为16。</span></span><br><span class="line"> <span class="keyword">char</span> comm[TASK_COMM_LEN];</span><br><span class="line"><span class="comment">/* 文件系统信息计数*/</span></span><br><span class="line"> <span class="keyword">int</span> link_count, total_link_count;</span><br><span class="line"><span class="comment">/*该进程在特定CPU下的状态*/</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">thread_struct</span> <span class="title">thread</span>;</span></span><br><span class="line"><span class="comment">/* 文件系统相关信息结构体*/</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">fs_struct</span> *<span class="title">fs</span>;</span></span><br><span class="line"><span class="comment">/* 打开的文件相关信息结构体*/</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> *<span class="title">files</span>;</span></span><br><span class="line"> <span class="comment">/* 信号相关信息的句柄*/</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">signal_struct</span> *<span class="title">signal</span>;</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">sighand_struct</span> *<span class="title">sighand</span>;</span></span><br><span class="line"> <span class="comment">/*这些是松弛时间值，用来规定select()和poll()的超时时间，单位是纳秒nanoseconds */</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">long</span> timer_slack_ns;</span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">long</span> default_timer_slack_ns;</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>如果需要获取其中的某些信息，获取对应的<code>task_struct</code>中的字段就可以了。在实际应用中，经常需要处理的就是获取当前进程的信息，这时候可以借助内核宏<code>current</code>，通过该宏可以获取到当前进程的<code>task_struct</code>。下面是针对<code>task_struct</code>的应用示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/sched.h&gt; //task_pid_nr</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* This function is called when the module is loaded. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">simple_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">       printk(KERN_INFO <span class="string">"Loading Module\n"</span>);</span><br><span class="line">       printk(<span class="string">"The process id is %d\n"</span>, (<span class="keyword">int</span>) task_pid_nr(current));</span><br><span class="line">       printk(<span class="string">"The process vid is %d\n"</span>, (<span class="keyword">int</span>) task_pid_vnr(current));</span><br><span class="line">       printk(<span class="string">"The process name is %s\n"</span>, current-&gt;comm);</span><br><span class="line">       printk(<span class="string">"The process tty is %d\n"</span>, current-&gt;signal-&gt;tty);</span><br><span class="line">       printk(<span class="string">"The process group is %d\n"</span>, (<span class="keyword">int</span>) task_tgid_nr(current));</span><br><span class="line">       printk(<span class="string">"\n\n"</span>);</span><br><span class="line">   <span class="comment">//return -1; //debug mode of working</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This function is called when the module is removed. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">simple_exit</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">"Removing Module\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Macros for registering module entry and exit points. */</span></span><br><span class="line">module_init( simple_init );</span><br><span class="line">module_exit( simple_exit );</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</span><br><span class="line">MODULE_DESCRIPTION(<span class="string">"Simple Module"</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">"SGG"</span>);</span><br></pre></td></tr></table></figure>
<p>在直接读取这些字段的时候可能引起竞争，所以可以使用<code>get_task_comm()</code>等函数来进行读取。<code>get_task_comm()</code>函数的定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> get_task_comm(buf, tsk) (&#123;            \</span></span><br><span class="line">   BUILD_BUG_ON(<span class="keyword">sizeof</span>(buf) != TASK_COMM_LEN); \</span><br><span class="line">   __get_task_comm(buf, <span class="keyword">sizeof</span>(buf), tsk);     \</span><br><span class="line"> &#125;)</span><br><span class="line"></span><br><span class="line"> <span class="keyword">char</span> *__get_task_comm(<span class="keyword">char</span> *buf, <span class="keyword">size_t</span> buf_size, struct task_struct *tsk)</span><br><span class="line"> &#123;</span><br><span class="line">   task_lock(tsk);</span><br><span class="line">   <span class="built_in">strncpy</span>(buf, tsk-&gt;comm, buf_size);</span><br><span class="line">   task_unlock(tsk);</span><br><span class="line">   <span class="keyword">return</span> buf;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>kernel</category>
        <category>pid</category>
      </categories>
      <tags>
        <tag>kernel</tag>
        <tag>pid</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo+github博客搭建</title>
    <url>/2020/05/08/hello-world/</url>
    <content><![CDATA[<p>&emsp;&emsp;hexo是一个博客框架，可以将markdown文本编译成静态网页。github提供了github pages,这是一个静态网站托管服务。所以前者生成的静态网页可以托管在github pages上。通过在网上搜索，发现<a href="https://cuiqingcai.com/7625.html" target="_blank" rel="noopener">这篇文章</a>写的很详细，根据这篇文章部署了该<a href="https://wdxx.github.io/" target="_blank" rel="noopener">博客网站</a>。</p>
<a id="more"></a>

<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>&emsp;&emsp;搭建前需要先安装好Node.js，可以通过<a href="https://nodejs.org/zh-cn/download/" target="_blank" rel="noopener">这里</a>下载安装。然后就是安装hexo与github pages创建。需要注意的是在申请github作为github pages的仓库时，仓库名需要是{name}.github.io的命名方式。如果你还没有github账户的话赶紧去<a href="https://github.com/" target="_blank" rel="noopener">官网</a>申请一个吧。</p>
<h3 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h3><p>安装命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>

<h2 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h2><p>&emsp;&emsp;到目前为止，我们的准备工作已经完成了，我们拥有了hexo框架，github仓库。接下来需要做的就是使用hexo来初始化一个博客项目，hexo提供了一个命令行工具，用于快速创建项目、页面、编译、部署hexo博客。创建博客项目的命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir myblogsite</span><br><span class="line"><span class="built_in">cd</span> myblogsite</span><br><span class="line">hexo init &#123;name&#125; <span class="comment">## name就是你要创建的项目的名字，一般取签名说的github的用户名就可以了。</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这个步骤中hexo为我们的博客项目创建了{name}文件夹，这个文件夹下面还有node_modules、scaffolds、themes等文件夹，先不管这些文件夹有啥作用，继续后面的步骤。我{name}文件夹下面可以看到一个source/_post文件夹，这个下面可以存放markdown个是的文本文件，hexo可以将这个文件编译成静态的html,然后我们就可以用来部署了。将markdown格式的文件编译成html的命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> &#123;name&#125;</span><br><span class="line">hexo generate <span class="comment">## 也可以使用  hexo g 命令</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;执行上面的命令后可以发现在{name}/public下生成了许多文件，这就是转换过程重生成的文件。可以通过如下的命令在本地调试查看生成的效果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在上面的命令执行完成后，如果服务启动正常，那么会打印如下的log：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">INFO  Start processing</span><br><span class="line">INFO  Hexo is running at http://localhost:4000 . Press Ctrl+C to stop.</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;可以看到，访问的地址为”<a href="http://localhost:4000&quot;，在浏览器中打开就可以看到效果了。">http://localhost:4000&quot;，在浏览器中打开就可以看到效果了。</a></p>
<h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>&emsp;&emsp;从上面的步骤中已经生成了静态的页面，接下来只需要部署到github就可以了。在部署之前需要安装一个git的部署插件，安装命令如下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;接下来需要配置部署地址。打开项目文件夹下面的”_config.yml”文件，找到”Deployment”配置项，配置成如下格式:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repo: https://github.com/wdxx/wdxx.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;将type配置成git,repo配置成github项目地址，branch配置成github仓库分支。配置完地址之后执行如下部署命令:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo deploy</span><br></pre></td></tr></table></figure>
<p>部署过程会上传编译好的结果，log如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Counting objects: 58, <span class="keyword">done</span>.</span><br><span class="line">Delta compression using up to 4 threads.</span><br><span class="line">Compressing objects: 100% (52/52), <span class="keyword">done</span>.</span><br><span class="line">Writing objects: 100% (58/58), 358.87 KiB | 0 bytes/s, <span class="keyword">done</span>.</span><br><span class="line">Total 58 (delta 8), reused 0 (delta 0)</span><br><span class="line">remote: Resolving deltas: 100% (8/8), <span class="keyword">done</span>.</span><br><span class="line">To https://github.com/wdxx/wdxx.github.io.git</span><br><span class="line">   3cd02f7..13b140e  HEAD -&gt; master</span><br><span class="line">Branch master <span class="built_in">set</span> up to track remote branch master from https://github.com/wdxx/wdxx.github.io.git.</span><br><span class="line">INFO  Deploy <span class="keyword">done</span>: git</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;现在就可以打开<a href="https://wdxx.github.io/" target="_blank" rel="noopener">https://wdxx.github.io/</a>看看部署好后的效果了。</p>
<h2 id="修改主题"><a href="#修改主题" class="headerlink" title="修改主题"></a>修改主题</h2><p>&emsp;&emsp;hexo提供了各种各样的主题用于定义自己喜欢的样式，一般使用最流行的<a href="https://github.com/theme-next/hexo-theme-next/tree/v7.8.0" target="_blank" rel="noopener">next</a>主题，主题需要自己单独下载，存放在工程的themes目录下。下载next的命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/theme-next/hexo-theme-next.git themes/next</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;下载完主题后，需要在工程目录的”_config.yml”中将主题切换为next,在该文件中找到”Extensions”字段，配置成如下格式:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line">theme: next</span><br></pre></td></tr></table></figure>

<h2 id="重新部署"><a href="#重新部署" class="headerlink" title="重新部署"></a>重新部署</h2><p>&emsp;&emsp;在修改完配置，或者新发布文章后，需要重新编译然后部署，命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo generate</span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure>

<h2 id="配置站点信息"><a href="#配置站点信息" class="headerlink" title="配置站点信息"></a>配置站点信息</h2><p>&emsp;&emsp;可以在 _config.yml 中修改大部分的配置。这里我们主要修改site区域的配置。各参数说明如下:  </p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="right">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">title</td>
<td align="right">网站标题</td>
</tr>
<tr>
<td align="left">subtitle</td>
<td align="right">网站副标题</td>
</tr>
<tr>
<td align="left">description</td>
<td align="right">网站描述</td>
</tr>
<tr>
<td align="left">keywords</td>
<td align="right">网站的关键词。使用半角逗号 , 分隔多个关键词</td>
</tr>
<tr>
<td align="left">author</td>
<td align="right">您的名字</td>
</tr>
<tr>
<td align="left">language</td>
<td align="right">网站使用的语言。对于简体中文用户来说，使用不同的主题可能需要设置成不同的值，请参考你的主题的文档自行设置，常见的有 zh-Hans和 zh-CN。</td>
</tr>
<tr>
<td align="left">timezone</td>
<td align="right">网站时区。Hexo 默认使用您电脑的时区。请参考 时区列表 进行设置，如 America/New_York, Japan, 和 UTC 。一般的，对于中国大陆地区可以使用 Asia/Shanghai。</td>
</tr>
</tbody></table>
<p>我的博客具体配置如下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Site</span></span><br><span class="line">title: wdxxliu</span><br><span class="line">subtitle: 个人博客</span><br><span class="line">description: 一个关于嵌入式方向的个人博客</span><br><span class="line">keywords: <span class="string">"Python C/C++ Makefile Linux 编译 工具链"</span></span><br><span class="line">author: wdxx</span><br><span class="line">language: zh-CN</span><br><span class="line">timezone: Asia/Shanghai</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>linux_filesystem</title>
    <url>/2020/08/19/linux-filesystem/</url>
    <content><![CDATA[<p>Linux中常见的文件系统是ext4文件系统，那文件系统的基本组成是什么样的呢？Linux操作系统中，文件除了实际的数据之外还有诸如权限、文件属性类的数据。文件系统通常会将实际的数据存放在<code>block</code>中，而权限及文件属性数据存放在<code>inode</code>中。</p>
<h2 id="inode-和-block-概述"><a href="#inode-和-block-概述" class="headerlink" title="inode 和 block 概述"></a>inode 和 block 概述</h2><p>文件是存储在硬盘上的，硬盘的最小存储单位叫做扇区<code>sector</code>，每个扇区存储<code>512字节</code>。操作系统读取硬盘的时候，不会一个个扇区地读取，这样效率太低，而是一次性连续读取多个扇区，即一次性读取一个块<code>block</code>。这种由多个扇区组成的块，是文件存取的最小单位。块的大小，最常见的是<code>4KB</code>，即连续八个sector组成一个<code>block</code>。</p>
<p>文件数据存储在块中，那么还必须找到一个地方存储文件的元信息，比如文件的创建者、文件的创建日期、文件的大小等等。这种存储文件元信息的区域就叫做<code>inode</code>，中文译名为<code>索引节点</code>，也叫<code>i节点</code>。因此，一个文件必须占用一个<code>inode</code>，但至少占用一个<code>block</code>。</p>
<ul>
<li>元信息：inode</li>
<li>数据: block</li>
</ul>
<h2 id="inode内容"><a href="#inode内容" class="headerlink" title="inode内容"></a>inode内容</h2><p><code>inode</code>包含很多的文件元信息，但不包含文件名，例如：字节数、属主<code>UserID</code>、属组<code>GroupID</code>、读写执行权限、时间戳等。</p>
<p>而文件名存放在目录当中，但Linux系统内部不使用文件名，而是使用<code>inode号码</code>识别文件。对于系统来说文件名只是<code>inode号码</code>便于识别的别称。</p>
<h2 id="inode号码"><a href="#inode号码" class="headerlink" title="inode号码"></a>inode号码</h2><p>可以通过<code>stat</code>命令或者<code>ls -i</code>命令查看文件或者目录的<code>inode号码</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">stat</span> readme.txt</span><br><span class="line">  文件：<span class="string">"readme.txt"</span></span><br><span class="line">  大小：6          块：8          IO 块：4096   普通文件</span><br><span class="line">设备：fc02h/64514d Inode：88617255    硬链接：1</span><br><span class="line">权限：(0664/-rw-rw-r--)  Uid：( 5002/xxx)   Gid：( 1003/xxx)</span><br><span class="line">最近访问：2020-08-19 10:19:33.431665414 +0800</span><br><span class="line">最近更改：2020-08-19 10:19:33.431665414 +0800</span><br><span class="line">最近改动：2020-08-19 10:19:33.431665414 +0800</span><br><span class="line">创建时间：-</span><br><span class="line"></span><br><span class="line">ls -i readme.txt</span><br><span class="line">88617255 readme.txt</span><br></pre></td></tr></table></figure>
<p>表面上，用户通过文件名打开文件，实际上，系统内部将这个过程分为三步：</p>
<ol>
<li>系统找到这个文件名对应的<code>inode号码</code>；</li>
<li>通过<code>inode号码</code>，获取<code>inode信息</code>；</li>
<li>根据<code>inode信息</code>，找到文件数据所在的<code>block</code>，并读出数据。<br>其实系统还要根据<code>inode信息</code>，看用户是否具有<code>访问权限</code>，有就指向对应的数据<code>block</code>，没有就返回权限拒绝。</li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
        <category>filesystem</category>
        <category>文件系统</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>filesystem</tag>
        <tag>文件系统</tag>
      </tags>
  </entry>
  <entry>
    <title>linux nfs 挂载</title>
    <url>/2020/09/03/linux-nfs/</url>
    <content><![CDATA[<p>在Linux服务器上使用nfs挂载需要先安装nfs server。下面是Ubuntu上安装nfs server的命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install nfs-kernel-server</span><br><span class="line"><span class="comment">## nfs 配置目录在/etc/exports</span></span><br></pre></td></tr></table></figure>
<p>客户端需要安装<code>nfs-common</code>,安装方法如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install nfs-common</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="nfs-server配置"><a href="#nfs-server配置" class="headerlink" title="nfs server配置"></a>nfs server配置</h3><p>nfs server的配置文件在<code>/etc/exports</code>文件中，需要有<code>root</code>权限才能编辑。例如<code>/work/nfs_share 192.168.2.55(rw,sync,no_subtree_check)</code>表示允许192.168.2.55使用nfs挂载当前服务器的<code>/work/nfs_share</code>目录。下面列举下nfs配置的各个参数：</p>
<ul>
<li>ro 该主机对该共享目录有只读权限</li>
<li>rw 该主机对该共享目录有读写权限</li>
<li>root_squash 客户机用root用户访问该共享文件夹时，将root用户映射成匿名用户</li>
<li>no_root_squash 客户机用root访问该共享文件夹时，不映射root用户</li>
<li>all_squash 客户机上的任何用户访问该共享目录时都映射成匿名用户</li>
<li>anonuid 将客户机上的用户映射成指定的本地用户ID的用户</li>
<li>anongid 将客户机上的用户映射成属于指定的本地用户组ID</li>
<li>sync 资料同步写入到内存与硬盘中</li>
<li>async 资料会先暂存于内存中，而非直接写入硬盘</li>
<li>insecure 允许从这台机器过来的非授权访问 </li>
<li>subtree_check 如果共享/usr/bin之类的子目录时，强制NFS检查父目录的权限（默认）</li>
<li>no_subtree_check 和上面相对，不检查父目录权限</li>
<li>wdelay 如果多个用户要写入NFS目录，则归组写入（默认）</li>
<li>no_wdelay 如果多个用户要写入NFS目录，则立即写入，当使用async时，无需此设置。</li>
<li>hide 在NFS共享目录中不共享其子目录</li>
<li>no_hide 共享NFS目录的子目录</li>
<li>secure NFS通过1024以下的安全TCP/IP端口发送</li>
<li>insecure NFS通过1024以上的端口发送<br>例子：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F; user01(rw) user02(rw,no_root_squash) 表示共享服务器上的根目录(&#x2F;)只有user01和user02两台主机可以访问，且有读写权限；user01主机用root用户身份访问时，将客户机的root用户映射成服务器上的匿名用户(root_squash,该参数为缺省参数)，相当于在服务器使用nobody用户访问目录；user02主机用root用户身份访问该共享目录时，不映射root用户(no_root_squash),即相当于在服务器上用root身份访问该目录</span><br><span class="line"></span><br><span class="line">　　&#x2F;root&#x2F;share&#x2F; 192.168.1.2(rw,insecure,sync,all_squash) 表示共享服务器上的&#x2F;root&#x2F;share&#x2F;目录只有192.168.1.2主机可以访问，且有读写权限；此主机用任何身份访问时，将客户机的用户都映射成服务器上的匿名用户(all_squash),相当于在服务器上用nobody用户访问该目录（若客户机要在该共享目录上保存文件（即写操作），则服务器上的nobody用户对该目录必须有写的权限）</span><br><span class="line"></span><br><span class="line">　　&#x2F;home&#x2F;ylw&#x2F; .test.com (rw,insecure,sync,all_squash) 表示共享&#x2F;home&#x2F;ylw&#x2F;目录，.test.com域中所有的主机都可以访问该目录，且有读写权限</span><br><span class="line"></span><br><span class="line">　　&#x2F;home&#x2F;share&#x2F; .test.com (ro,sync,all_squash,anonuid&#x3D;zh3,anongid&#x3D;wa4) 表示共享目录&#x2F;home&#x2F;share&#x2F;，*.test.com域中的所有主机都可以访问，但只有只读的权限，所有用户都映射成服务器上的uid为zh3、gid为wa4的用户</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/qq_36357820/article/details/78488077" target="_blank" rel="noopener">https://blog.csdn.net/qq_36357820/article/details/78488077</a></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>oracle</title>
    <url>/2020/11/20/oracle/</url>
    <content><![CDATA[<p>Oracle数据库跟MySql数据库要复杂一些，有数据库、数据库实例等概念。</p>
<h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p>Oracle中的数据库指的是物理上的数据库文件或者磁盘中的数据，用户需要通过数据库实例来操作数据库。</p>
<h3 id="数据库实例"><a href="#数据库实例" class="headerlink" title="数据库实例"></a>数据库实例</h3><p>Oracle 实例是客户端应用程序(用户)和数据库之间的接口。也就是说数据库实例就是一个Oracle数据库服务器中某个后台进程，用户通过这个进程来访问对应的数据库。所以在Oracle链接的时候，是需要指定数据库实例服务名的。</p>
<a id="more"></a>

<h3 id="第一次登录"><a href="#第一次登录" class="headerlink" title="第一次登录"></a>第一次登录</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sqlplus /nolog</span><br><span class="line">connect / as sysdba</span><br><span class="line">select username,account_status from dba_users;</span><br><span class="line"><span class="comment">### 第一次登录，为sys、system用户设置初始密码</span></span><br><span class="line">alter user sys identified by 123456;</span><br><span class="line">alter user system identified by 123456;</span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line"><span class="comment">### sys 用户登录</span></span><br><span class="line">sys as sysdba</span><br><span class="line"><span class="comment">### 创建WORK用户，注意需要以C##开头</span></span><br><span class="line">CREATE USER C<span class="comment">##WORK IDENTIFIED BY 123456;</span></span><br></pre></td></tr></table></figure>

<h3 id="监听器无法启动"><a href="#监听器无法启动" class="headerlink" title="监听器无法启动"></a>监听器无法启动</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lsnrctl start LISTENER</span><br><span class="line">Starting tnslsnr:</span><br><span class="line"></span><br><span class="line">TNS-12557:TNS:protocol adapter not loadable</span><br><span class="line">TNS-12560:TNS:protocol adapter error</span><br><span class="line">TNS-00527:Protocol Adapter not loadable</span><br></pre></td></tr></table></figure>

<p>listener.ora</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># listener.ora Network Configuration File: D:\WINDOWS.X64_193000_db_home\NETWORK\ADMIN\listener.ora</span><br><span class="line"># Generated by Oracle configuration tools.</span><br><span class="line"></span><br><span class="line">SID_LIST_LISTENER &#x3D;</span><br><span class="line">  (SID_LIST &#x3D;</span><br><span class="line">    (SID_DESC &#x3D;</span><br><span class="line">      (SID_NAME &#x3D; CLRExtProc)</span><br><span class="line">      (ORACLE_HOME &#x3D; D:\WINDOWS.X64_193000_db_home)</span><br><span class="line">      (PROGRAM &#x3D; extproc)</span><br><span class="line">      (ENVS &#x3D; &quot;EXTPROC_DLLS&#x3D;ONLY:D:\WINDOWS.X64_193000_db_home\bin\oraclr19.dll&quot;)</span><br><span class="line">    )</span><br><span class="line">    (SID_DESC &#x3D;</span><br><span class="line">      (SID_NAME &#x3D; ORCL)</span><br><span class="line">      (ORACLE_HOME &#x3D; D:\WINDOWS.X64_193000_db_home)</span><br><span class="line">      (SID_NAME &#x3D; ORCL)</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">LISTENER &#x3D;</span><br><span class="line">  (DESCRIPTION_LIST &#x3D;</span><br><span class="line">    (DESCRIPTION &#x3D;</span><br><span class="line">      (ADDRESS &#x3D; (PROTOCOL &#x3D; TCP)(HOST &#x3D; 127.0.0.1)(PORT &#x3D; 1521))</span><br><span class="line">      (ADDRESS &#x3D; (PROTOCOL &#x3D; IPC)(KEY &#x3D; EXTPROC1521))</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">ADR_BASE_LISTENER &#x3D; D:\WINDOWS.X64_193000_db_home\log</span><br></pre></td></tr></table></figure>

<p>tnsnames.ora</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># tnsnames.ora Network Configuration File: D:\WINDOWS.X64_193000_db_home\NETWORK\ADMIN\tnsnames.ora</span><br><span class="line"># Generated by Oracle configuration tools.</span><br><span class="line"></span><br><span class="line">ORACLR_CONNECTION_DATA &#x3D;</span><br><span class="line">  (DESCRIPTION &#x3D;</span><br><span class="line">    (ADDRESS_LIST &#x3D;</span><br><span class="line">      (ADDRESS &#x3D; (PROTOCOL &#x3D; IPC)(Key &#x3D; EXTPROC))</span><br><span class="line">    )</span><br><span class="line">    (CONNECT_DATA &#x3D;</span><br><span class="line">      (SID &#x3D; CLRExtProc)</span><br><span class="line">      (PRESENTATION &#x3D; RO)</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">ORCL &#x3D;</span><br><span class="line">  (DESCRIPTION &#x3D;</span><br><span class="line">    (ADDRESS_LIST &#x3D;</span><br><span class="line">      (ADDRESS &#x3D; (PROTOCOL &#x3D; TCP)(HOST &#x3D; 127.0.0.1)(PORT &#x3D; 1521))</span><br><span class="line">    )</span><br><span class="line">    (CONNECT_DATA &#x3D;</span><br><span class="line">      (SERVICE_NAME &#x3D; ORCL)</span><br><span class="line">    )</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>

<h3 id="oracle-windows环境"><a href="#oracle-windows环境" class="headerlink" title="oracle windows环境"></a>oracle windows环境</h3><p>如果使用vs在windows环境下进行开发，需要安装ODTwithODAC。下载地址如下：<br><a href="https://download.oracle.com/otn/other/ole-oo4o/ODTwithODAC122011.zip?AuthParam=1604376209_ac2af019fab4ad7c6eb8360fec98cd0b" target="_blank" rel="noopener">https://download.oracle.com/otn/other/ole-oo4o/ODTwithODAC122011.zip?AuthParam=1604376209_ac2af019fab4ad7c6eb8360fec98cd0b</a></p>
<h2 id="windows编程"><a href="#windows编程" class="headerlink" title="windows编程"></a>windows编程</h2><h3 id="Windows-VS-ADO"><a href="#Windows-VS-ADO" class="headerlink" title="Windows VS ADO"></a>Windows VS ADO</h3><p>关于ADO的介绍参考：<a href="https://blog.csdn.net/i_likechard/article/details/81386694" target="_blank" rel="noopener">https://blog.csdn.net/i_likechard/article/details/81386694</a></p>
<p><a href="https://blog.csdn.net/luke2834/article/details/47778639" target="_blank" rel="noopener">https://blog.csdn.net/luke2834/article/details/47778639</a></p>
<p><a href="https://www.cnblogs.com/TenosDoIt/archive/2013/04/15/3022136.html" target="_blank" rel="noopener">https://www.cnblogs.com/TenosDoIt/archive/2013/04/15/3022136.html</a></p>
<p><a href="https://blog.csdn.net/lbcab/article/details/51329207" target="_blank" rel="noopener">https://blog.csdn.net/lbcab/article/details/51329207</a></p>
<p><a href="https://blog.csdn.net/shen_jz2012/article/details/51759858" target="_blank" rel="noopener">https://blog.csdn.net/shen_jz2012/article/details/51759858</a></p>
<h3 id="Microsoft-官方示例"><a href="#Microsoft-官方示例" class="headerlink" title="Microsoft 官方示例"></a>Microsoft 官方示例</h3><p><a href="https://docs.microsoft.com/zh-cn/office/client-developer/access/desktop-database-reference/ado-code-examples-in-microsoft-visual-c" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/office/client-developer/access/desktop-database-reference/ado-code-examples-in-microsoft-visual-c</a></p>
<h3 id="SOCI使用"><a href="#SOCI使用" class="headerlink" title="SOCI使用"></a>SOCI使用</h3><p><a href="https://www.jianshu.com/p/66ac4e90c602" target="_blank" rel="noopener">https://www.jianshu.com/p/66ac4e90c602</a></p>
]]></content>
      <categories>
        <category>oracle</category>
      </categories>
      <tags>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>将modules和exponent转换为公钥</title>
    <url>/2020/05/22/modulus-and-exponent-to-publicKey/</url>
    <content><![CDATA[<p>&emsp;&emsp;在使用加解密时，有时候我们拿到的是公钥中的modulus和exponent字段，当需要通过使用openssl工具进行验签或者加密的时候，就需要将这些信息转换成公钥了。本文介绍如何将modules和exponent转换为公钥。</p>
<a id="more"></a>
<h2 id="公钥文件分析"><a href="#公钥文件分析" class="headerlink" title="公钥文件分析"></a>公钥文件分析</h2><p>使用如下命令dump出公钥的信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ openssl rsa -pubin -in  pub.pem -noout -text</span><br><span class="line">Public-Key: (2048 bit)</span><br><span class="line">Modulus:</span><br><span class="line">    00:a0:10:a8:32:0b:cb:75:db:7d:8e:ba:a5:df:56:</span><br><span class="line">    b2:fb:9c:e9:34:b3:ae:7b:0b:07:a6:13:40:28:13:</span><br><span class="line">    be:78:5f:69:09:c1:bb:5e:52:62:aa:a3:f5:38:5d:</span><br><span class="line">    70:c2:3c:95:05:71:e8:87:57:10:a0:5d:7b:8a:f7:</span><br><span class="line">    dd:a3:e4:85:f5:e1:e7:ba:e2:34:4c:18:9f:46:55:</span><br><span class="line">    15:49:b5:48:92:22:ed:84:24:17:86:bf:69:10:55:</span><br><span class="line">    42:76:4b:55:bf:d3:ce:a4:2a:bd:5e:a2:e5:29:84:</span><br><span class="line">    4f:77:08:3a:22:04:5c:00:de:8b:9b:ee:7f:68:b0:</span><br><span class="line">    b0:9b:e8:bb:b1:99:e6:8a:cf:9e:b9:85:d2:86:d3:</span><br><span class="line">    5e:c2:a4:56:8d:f8:87:1d:6c:b3:73:83:3e:7b:bc:</span><br><span class="line">    5d:c6:e2:63:fd:e1:4d:18:df:53:0f:4e:13:6f:fd:</span><br><span class="line">    a6:b7:8c:e9:26:a3:4e:2b:fd:61:3d:d1:b5:f4:2f:</span><br><span class="line">    ad:55:12:57:2a:20:ed:30:e7:64:3c:87:26:47:ef:</span><br><span class="line">    97:48:30:df:44:f2:ed:c6:54:ed:5e:4f:dd:d9:3d:</span><br><span class="line">    64:51:02:f9:7b:56:77:44:63:b0:95:1a:5e:83:4b:</span><br><span class="line">    82:ce:59:f2:9e:e1:fc:16:1c:fc:f6:9c:55:37:73:</span><br><span class="line">    ae:6a:e9:76:0c:9e:3a:b1:fc:cf:76:20:6b:17:d4:</span><br><span class="line">    87:c3</span><br><span class="line">Exponent: 65537 (0x10001)</span><br></pre></td></tr></table></figure>
<p>从上面的信息可以看到<code>exponent</code>的值为<code>65537</code>。上面的信息中发现我们的public key的长度是2048位的，但是modulus有257个字节，合计2056（257*8）位,经过验证发现<code>modulus</code>中的第一位<code>00</code>是不需要的。后面根据<a href="https://stackoverflow.com/questions/5403808/private-key-length-bytes" target="_blank" rel="noopener">网上资料</a>发现rsa格式的密钥，它的密钥长度跟<code>modulus</code>的长度是一致的，第一位<code>00</code>不影响<code>modulus</code>的大小，也就不会影响公钥的长度了。  </p>
<h3 id="导出hex格式的modulus"><a href="#导出hex格式的modulus" class="headerlink" title="导出hex格式的modulus"></a>导出hex格式的modulus</h3><p>通过openssl asn1parse可以查看密钥的格式,关于pem格式的密钥的介绍请看<a href="https://www.cnblogs.com/adylee/p/9366518.html" target="_blank" rel="noopener">这里</a>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ openssl asn1parse -in pub.pem  -i</span><br><span class="line">    0:d&#x3D;0  hl&#x3D;4 l&#x3D; 290 cons: SEQUENCE          </span><br><span class="line">    4:d&#x3D;1  hl&#x3D;2 l&#x3D;  13 cons:  SEQUENCE          </span><br><span class="line">    6:d&#x3D;2  hl&#x3D;2 l&#x3D;   9 prim:   OBJECT            :rsaEncryption</span><br><span class="line">   17:d&#x3D;2  hl&#x3D;2 l&#x3D;   0 prim:   NULL              </span><br><span class="line">   19:d&#x3D;1  hl&#x3D;4 l&#x3D; 271 prim:  BIT STRING</span><br></pre></td></tr></table></figure>
<p>其中<code>BIT STRING</code>就是modulus，可以看到它的<code>offset</code>为19,通过如下命令导出hex格式的modulus：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ openssl asn1parse -in pub.pem  -i -dump -strparse 19</span><br><span class="line">    0:d&#x3D;0  hl&#x3D;4 l&#x3D; 266 cons: SEQUENCE          </span><br><span class="line">    4:d&#x3D;1  hl&#x3D;4 l&#x3D; 257 prim: INTEGER           :A010A8320BCB75DB7D8EBAA5DF56B2FB9CE934B3AE7B0B07A613402813BE785F6909C1BB5E5262AAA3F5385D70C23C950571E8875710A05D7B8AF7DDA3E485F5E1E7BAE2344C189F46551549B5489222ED84241786BF69105542764B55BFD3CEA42ABD5EA2E529844F77083A22045C00DE8B9BEE7F68B0B09BE8BBB199E68ACF9EB985D286D35EC2A4568DF8871D6CB373833E7BBC5DC6E263FDE14D18DF530F4E136FFDA6B78CE926A34E2BFD613DD1B5F42FAD5512572A20ED30E7643C872647EF974830DF44F2EDC654ED5E4FDDD93D645102F97B56774463B0951A5E834B82CE59F29EE1FC161CFCF69C553773AE6AE9760C9E3AB1FCCF76206B17D487C3</span><br><span class="line">  265:d&#x3D;1  hl&#x3D;2 l&#x3D;   3 prim: INTEGER           :010001</span><br></pre></td></tr></table></figure>
<p>可以看到其中的modulus跟上小节中使用<code>openssl rsa</code>命令导出的一样，但是去掉了开头的<code>00</code>。</p>
<h2 id="提取公钥"><a href="#提取公钥" class="headerlink" title="提取公钥"></a>提取公钥</h2><p>这里对公钥的提取需要使用到Python的<a href="https://github.com/dlitz/pycrypto" target="_blank" rel="noopener">pycrypto</a>库。代码如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.PublicKey.RSA <span class="keyword">import</span> construct</span><br><span class="line">e = long(<span class="number">65537</span>) <span class="comment">## Exponent</span></span><br><span class="line">n = int(<span class="string">'A010A8320BCB75DB7D8EBAA5DF56B2FB9CE934B3AE7B0B07A613402813BE785F6909C1BB5E5262AAA3F5385D70C23C950571E8875710A05D7B8AF7DDA3E485F5E1E7BAE2344C189F46551549B5489222ED84241786BF69105542764B55BFD3CEA42ABD5EA2E529844F77083A22045C00DE8B9BEE7F68B0B09BE8BBB199E68ACF9EB985D286D35EC2A4568DF8871D6CB373833E7BBC5DC6E263FDE14D18DF530F4E136FFDA6B78CE926A34E2BFD613DD1B5F42FAD5512572A20ED30E7643C872647EF974830DF44F2EDC654ED5E4FDDD93D645102F97B56774463B0951A5E834B82CE59F29EE1FC161CFCF69C553773AE6AE9760C9E3AB1FCCF76206B17D487C3'</span>, <span class="number">16</span>) <span class="comment">## modulus</span></span><br><span class="line">pubkey = construct((n, e))</span><br><span class="line">strkey = pubkey.exportKey()</span><br><span class="line"><span class="keyword">print</span> strkey</span><br></pre></td></tr></table></figure>
<p>需要注意的是e、n都需要是long类型的，不然会报错，最终获取到如下的key。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-----BEGIN PUBLIC KEY-----</span><br><span class="line">MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAoBCoMgvLddt9jrql31ay</span><br><span class="line">+5zpNLOuewsHphNAKBO+eF9pCcG7XlJiqqP1OF1wwjyVBXHoh1cQoF17ivfdo+SF</span><br><span class="line">9eHnuuI0TBifRlUVSbVIkiLthCQXhr9pEFVCdktVv9POpCq9XqLlKYRPdwg6IgRc</span><br><span class="line">AN6Lm+5&#x2F;aLCwm+i7sZnmis+euYXShtNewqRWjfiHHWyzc4M+e7xdxuJj&#x2F;eFNGN9T</span><br><span class="line">D04Tb&#x2F;2mt4zpJqNOK&#x2F;1hPdG19C+tVRJXKiDtMOdkPIcmR++XSDDfRPLtxlTtXk&#x2F;d</span><br><span class="line">2T1kUQL5e1Z3RGOwlRpeg0uCzlnynuH8Fhz89pxVN3Ouaul2DJ46sfzPdiBrF9SH</span><br><span class="line">wwIDAQAB</span><br><span class="line">-----END PUBLIC KEY-----</span><br></pre></td></tr></table></figure>

<h3 id="关于Crypto-PublicKey-RSA-construct"><a href="#关于Crypto-PublicKey-RSA-construct" class="headerlink" title="关于Crypto.PublicKey.RSA.construct"></a>关于Crypto.PublicKey.RSA.construct</h3><p>下面是Crypto.PublicKey.RSA.construct方法的介绍:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;&quot;&quot;Construct an RSA key from a tuple of valid RSA components.</span><br><span class="line">The modulus **n** must be the product of two primes.</span><br><span class="line">The public exponent **e** must be odd and larger than 1.</span><br><span class="line">In case of a private key, the following equations must apply:</span><br><span class="line">- e !&#x3D; 1</span><br><span class="line">- p*q &#x3D; n</span><br><span class="line">- e*d &#x3D; 1 mod (p-1)(q-1)</span><br><span class="line">- p*u &#x3D; 1 mod q</span><br><span class="line">:Parameters:</span><br><span class="line"> tup : tuple</span><br><span class="line">            A tuple of long integers, with at least 2 and no</span><br><span class="line">            more than 6 items. The items come in the following order:</span><br><span class="line">            1. RSA modulus (n).</span><br><span class="line">            2. Public exponent (e).</span><br><span class="line">            3. Private exponent (d). Only required if the key is private.</span><br><span class="line">            4. First factor of n (p). Optional.</span><br><span class="line">            5. Second factor of n (q). Optional.</span><br><span class="line">            6. CRT coefficient, (1&#x2F;p) mod q (u). Optional.</span><br><span class="line"></span><br><span class="line">:Return: An RSA key object (&#96;_RSAobj&#96;).</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>
<p>想要了解这堆说明，需要先了解下<a href="https://zhuanlan.zhihu.com/p/44185847" target="_blank" rel="noopener"><code>RSA</code>算法的原理</a>。根据这篇文章我们可以知道如下几点：<br>1、 模数n = p<em>q,其中q与q互质<br>2、 e是一个随机数，它不等于1，并且与(q-1)</em>(p-1)互质。（算法上m = (q-1)<em>(p-1)）。<br>3、 d是一个整数，(e</em>d)%m = 1, 这里得到的d是私钥的一部分。<br>公钥：(n, e)<br>私钥：(n, d)</p>
<h4 id="加密过程"><a href="#加密过程" class="headerlink" title="加密过程"></a>加密过程</h4><p>假设明文为a，那么密文b = a^e % n，可以看到我们用到了<code>(n, e)</code>，所以加密的时候是使用公钥进行加密的。其中需要注意的是，要想使用公钥（n，e) 加密，要求被加密的数字必须小于n。</p>
<h4 id="解密过程"><a href="#解密过程" class="headerlink" title="解密过程"></a>解密过程</h4><p>解密的时候用到私钥<code>(n, d)</code>，假设接收到的密文b,那么想要得到明文a,则需要通过如下计算：<br>a = b^d %n。</p>
<h3 id="关于验证过程中的注意事项"><a href="#关于验证过程中的注意事项" class="headerlink" title="关于验证过程中的注意事项"></a>关于验证过程中的注意事项</h3><p>验证的时候保证明文的一致性，如明文存在文件中，由于windows 、linux文件格式不一样，可能看上去字符串一样，但是文件的hash是不一样的。</p>
]]></content>
      <categories>
        <category>加解密</category>
        <category>openssl</category>
      </categories>
      <tags>
        <tag>加解密</tag>
        <tag>openssl</tag>
      </tags>
  </entry>
  <entry>
    <title>openssl初探</title>
    <url>/2020/05/21/openssl-first/</url>
    <content><![CDATA[<h2 id="非对称加密算法概述"><a href="#非对称加密算法概述" class="headerlink" title="非对称加密算法概述"></a>非对称加密算法概述</h2><p>&emsp;&emsp;非对称加密算法也称公开密钥算法，其解决了对称加密算法密钥分配的问题，非对称加密算法基本特点如下：<br>1、加密密钥和解密密钥不同<br>2、密钥对中的一个密钥可以公开<br>3、根据公开密钥很难推算出私人密钥<br>&emsp;&emsp;根据非对称加密算法的特点，可用户数字签名、密钥交换、数据加密。但是由于非对称加密算法较对称加密算法加密速度慢很多，故最常用的用途是数字签名和密钥交换。<br>&emsp;&emsp;目前常用的非对称加密算法有RSA, DH和DSA三种，但并非都可以用于密钥交换和数字签名。而是RSA可用于数字签名和密钥交换，DH算法可用于密钥交换，而DSA算法专门用户数字签名。<br>&emsp;&emsp;openssl支持以上三种算法，并为三种算法提供了丰富的指令集，目前使用最多的算法是rsa加密算法，本文介绍OpenSSL在rsa加密算法上的使用。</p>
<a id="more"></a>

<h2 id="openssl-rsa算法相关指令与用法"><a href="#openssl-rsa算法相关指令与用法" class="headerlink" title="openssl rsa算法相关指令与用法"></a>openssl rsa算法相关指令与用法</h2><p>&emsp;&emsp;RSA虽然可以数字签名、密钥交换和数据加密，但是RSA加密数据速度慢，通常不使用RSA加密数据。对于在实际应用中是使用RSA算法进行签名还是进行加密，可以通过公钥与私钥的使用进行区别：<br>&emsp;&emsp;公钥加密：用途是密钥交换，用户A使用用户B的公钥将少量数据加密发送给B，B用自己的私钥解密数据。<br>&emsp;&emsp;私钥签名：用途是数字签名，用户A使用自己的私钥将数据的摘要信息加密一并发送给B，B用A的公钥解密摘要信息并验证。</p>
<h3 id="openssl-genrsa命令介绍"><a href="#openssl-genrsa命令介绍" class="headerlink" title="openssl genrsa命令介绍"></a>openssl genrsa命令介绍</h3><p>openssl genras 命令用于生成秘钥对，其用法如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xxx@cmos:~$ openssl genrsa -</span><br><span class="line">usage: genrsa [args] [numbits]                                                     //密钥位数，建议1024及以上</span><br><span class="line"> -des            encrypt the generated key with DES <span class="keyword">in</span> cbc mode                    //生成的密钥使用des方式进行加密</span><br><span class="line"> -des3           encrypt the generated key with DES <span class="keyword">in</span> ede cbc mode (168 bit key)  //生成的密钥使用des3方式进行加密</span><br><span class="line"> -seed</span><br><span class="line">                 encrypt PEM output with cbc seed                                  //生成的密钥还是要seed方式进行</span><br><span class="line"> -aes128, -aes192, -aes256</span><br><span class="line">                 encrypt PEM output with cbc aes                                   //生成的密钥使用aes方式进行加密</span><br><span class="line"> -camellia128, -camellia192, –camellia256 </span><br><span class="line">                 encrypt PEM output with cbc camellia                              //生成的密钥使用camellia方式进行加密</span><br><span class="line"> -out file       output the key to <span class="string">'file                                           //生成的密钥文件，可从中提取公钥</span></span><br><span class="line"><span class="string"> -passout arg    output file pass phrase source                                    //指定密钥文件的加密口令，可从文件、环境变量、终端等输入</span></span><br><span class="line"><span class="string"> -f4             use F4 (0x10001) for the E value                                  //选择指数e的值，默认指定该项，e值为65537 -3              use 3 for the E value                                             //选择指数e的值，默认值为65537，使用该选项则指数指定为3</span></span><br><span class="line"><span class="string"> -engine e       use engine e, possibly a hardware device.                         //指定三方加密库或者硬件</span></span><br><span class="line"><span class="string"> -rand file:file:...</span></span><br><span class="line"><span class="string">                 load the file (or the files in the directory) into                //产生随机数的种子文件</span></span><br><span class="line"><span class="string">                 the random number generator</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;通过上面的使用介绍我们来创建一个私钥，我们指定私钥的加密算法为aes128，创建密码为123456（在使用私钥时需要输入密码，如果设置了创建密码），密钥位数为2048位。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">openssl genrsa -aes128 -out rsa_2048.pem -passout pass:123456 2048</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在创建rsa私钥的时候是必须设置口令的，此密码用于加密私钥文件。以后在使用openssl提供的命令或者api再操作此私钥文件时需要输入口令。如果觉得输入口令不方便，也可以通过如下命令将口令去除：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">openssl rsa -in rsa_2048.pem -out rsa_2048.pem</span><br></pre></td></tr></table></figure>

<h3 id="openssl-rsa-命令介绍"><a href="#openssl-rsa-命令介绍" class="headerlink" title="openssl rsa 命令介绍"></a>openssl rsa 命令介绍</h3><p>rsa指令用户管理生成的密钥，其用法如下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xxx@cmos:~$ openssl rsa -</span><br><span class="line">unknown option -</span><br><span class="line">rsa [options] &lt;infile &gt;outfile     </span><br><span class="line"><span class="built_in">where</span> options are</span><br><span class="line"> -inform arg     input format - one of DER NET PEM                      //输入文件格式，默认pem格式</span><br><span class="line"> -outform arg    output format - one of DER NET PEM                     //输入文件格式，默认pem格式</span><br><span class="line"> -<span class="keyword">in</span> arg         input file                                             //输入文件</span><br><span class="line"> -sgckey         Use IIS SGC key format                                 //指定SGC编码格式，兼容老版本，不应再使用</span><br><span class="line"> -passin arg     input file pass phrase <span class="built_in">source</span>                          //指定输入文件的加密口令，可来自文件、终端、环境变量等</span><br><span class="line"> -out arg        output file                                            //输出文件</span><br><span class="line"> -passout arg    output file pass phrase <span class="built_in">source</span>                         //指定输出文件的加密口令，可来自文件、终端、环境变量等</span><br><span class="line"> -des            encrypt PEM output with cbc des                        //使用des加密输出的文件</span><br><span class="line"> -des3           encrypt PEM output with ede cbc des using 168 bit key  //使用des3加密输出的文件</span><br><span class="line"> -seed           encrypt PEM output with cbc seed                       //使用seed加密输出的文件</span><br><span class="line"> -aes128, -aes192, -aes256</span><br><span class="line">                 encrypt PEM output with cbc aes                        //使用aes加密输出的文件</span><br><span class="line"> -camellia128, -camellia192, -camellia256</span><br><span class="line">                 encrypt PEM output with cbc camellia                   //使用camellia加密输出的文件呢</span><br><span class="line"> -text           <span class="built_in">print</span> the key <span class="keyword">in</span> text                                  //以明文形式输出各个参数值</span><br><span class="line"> -noout          don<span class="string">'t print key out                                    //不输出密钥到任何文件</span></span><br><span class="line"><span class="string"> -modulus        print the RSA key modulus                              //输出模数指</span></span><br><span class="line"><span class="string"> -check          verify key consistency                                 //检查输入密钥的正确性和一致性</span></span><br><span class="line"><span class="string"> -pubin          expect a public key in input file                      //指定输入文件是公钥</span></span><br><span class="line"><span class="string"> -pubout         output a public key                                    //指定输出文件是公钥</span></span><br><span class="line"><span class="string"> -engine e       use engine e, possibly a hardware device.              //指定三方加密库或者硬件</span></span><br><span class="line"><span class="string">xlzh@cmos:~$</span></span><br></pre></td></tr></table></figure>
<ol>
<li><p>rsa添加和去除密钥的保护口令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/*生成不加密的RSA密钥*/</span><br><span class="line">xxx@cmos:~/<span class="built_in">test</span>$ openssl genrsa -out RSA.pem</span><br><span class="line">Generating RSA private key, 512 bit long modulus</span><br><span class="line">..............++++++++++++</span><br><span class="line">.....++++++++++++</span><br><span class="line">e is 65537 (0x10001)</span><br><span class="line">/*为RSA密钥增加口令保护*/</span><br><span class="line">xxx@cmos:~/<span class="built_in">test</span>$ openssl rsa -<span class="keyword">in</span> RSA.pem -des3 -passout pass:123456 -out E_RSA.pem</span><br><span class="line">writing RSA key</span><br><span class="line">/*为RSA密钥去除口令保护*/</span><br><span class="line">xxx@cmos:~/<span class="built_in">test</span>$ openssl rsa -<span class="keyword">in</span> E_RSA.pem -passin pass:123456 -out P_RSA.pem</span><br><span class="line">writing RSA key</span><br><span class="line">/*比较原始后的RSA密钥和去除口令后的RSA密钥，是一样*/</span><br><span class="line">xxx@cmos:~/<span class="built_in">test</span>$ diff RSA.pem P_RSA.pem</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改密钥的保护口令与算法</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/*生成RSA密钥*/</span><br><span class="line">xxx@cmos:~/<span class="built_in">test</span>$ openssl genrsa -des3 -passout pass:123456 -out RSA.pem</span><br><span class="line">Generating RSA private key, 512 bit long modulus</span><br><span class="line">..................++++++++++++</span><br><span class="line">......................++++++++++++</span><br><span class="line">e is 65537 (0x10001)</span><br><span class="line">/*修改加密算法为aes128，口令是123456*/</span><br><span class="line">xxx@cmos:~/<span class="built_in">test</span>$ openssl rsa -<span class="keyword">in</span> RSA.pem -passin pass:123456 -aes128 -passout pass:123456 -out E_RSA.pem</span><br><span class="line">writing RSA key</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看密钥对中的各个参数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xxx@cmos:~/<span class="built_in">test</span>$ openssl rsa -<span class="keyword">in</span> RSA.pem -des -passin pass:123456 -text -noout</span><br></pre></td></tr></table></figure>
</li>
<li><p>提取密钥中的公钥并打印模数值(生成私钥后，一般第一步就是导出公钥)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/*提取公钥，用pubout参数指定输出为公钥*/</span><br><span class="line">xxx@cmos:~/<span class="built_in">test</span>$ openssl rsa -<span class="keyword">in</span> RSA.pem -passin pass:123456 -pubout -out pub.pem</span><br><span class="line">writing RSA key</span><br><span class="line">/*打印公钥中模数值*/</span><br><span class="line">xxx@cmos:~/<span class="built_in">test</span>$ openssl rsa -<span class="keyword">in</span> pub.pem -pubin -modulus -noout</span><br><span class="line">Modulus=C35E0B54041D78466EAE7DE67C1DA4D26575BC1608CE6A199012E11D10ED36E2F7C651D4D8B40D93691D901E2CF4E21687E912B77DCCE069373A7F6585E946EF</span><br></pre></td></tr></table></figure>
</li>
<li><p>转换密钥的格式</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/*把pem格式转化成der格式，使用outform指定der格式*/</span><br><span class="line">xxx@cmos:~/<span class="built_in">test</span>$ openssl rsa -<span class="keyword">in</span> RSA.pem -passin pass:123456 -des -passout pass:123456 -outform der -out rsa.der</span><br><span class="line">writing RSA key</span><br><span class="line">/*把der格式转化成pem格式，使用inform指定der格式*/</span><br><span class="line">xxx@cmos:~/<span class="built_in">test</span>$ openssl rsa -<span class="keyword">in</span> rsa.der -inform der -passin pass:123456 -out rsa.pem</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="openssl-rsautl-命令介绍"><a href="#openssl-rsautl-命令介绍" class="headerlink" title="openssl rsautl 命令介绍"></a>openssl rsautl 命令介绍</h3><p>&emsp;&emsp;前面介绍的genrsa与rsa命令是生成密钥与对密钥进行管理的命令，rsautl则是真正用于密钥交换和数字签名，实质上就是用公钥或者私钥进行加密。<br>&emsp;&emsp;而无论是使用公钥加密还是私钥加密，RSA每次能够加密的数据长度不能超过RSA密钥长度，并且根据具体的补齐方式不同输入的加密数据最大长度也不一样，而输出长度则总是跟RSA密钥长度相等。RSA不同的补齐方法对应的输入输入长度如下表：  </p>
<table>
<thead>
<tr>
<th align="left">数据补齐方式</th>
<th align="left">输入数据长度</th>
<th align="left">输出数据长度</th>
<th align="right">参数字符串</th>
</tr>
</thead>
<tbody><tr>
<td align="left">PKCS#1 v1.5</td>
<td align="left">少于(密钥长度-11)字节</td>
<td align="left">同密钥长度</td>
<td align="right">-pkcs</td>
</tr>
<tr>
<td align="left">PKCS#1 OAEP</td>
<td align="left">少于(密钥长度-11)字节</td>
<td align="left">同密钥长度</td>
<td align="right">-oaep</td>
</tr>
<tr>
<td align="left">PKCS#1 for SSLv23</td>
<td align="left">少于(密钥长度-11)字节</td>
<td align="left">同密钥长度</td>
<td align="right">-ssl</td>
</tr>
<tr>
<td align="left">不使用补齐</td>
<td align="left">同密钥长度</td>
<td align="left">同密钥长度</td>
<td align="right">-raw</td>
</tr>
</tbody></table>
<p>rsautl指令用法如下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xlzh@cmos:~$ openssl rsautl - </span><br><span class="line">Usage: rsautl [options]                  </span><br><span class="line">-<span class="keyword">in</span> file        input file                                           //输入文件</span><br><span class="line">-out file       output file                                          //输出文件</span><br><span class="line">-inkey file     input key                                            //输入的密钥</span><br><span class="line">-keyform arg    private key format - default PEM                     //指定密钥格式</span><br><span class="line">-pubin          input is an RSA public                               //指定输入的是RSA公钥</span><br><span class="line">-certin         input is a certificate carrying an RSA public key    //指定输入的是证书文件</span><br><span class="line">-ssl            use SSL v2 padding                                   //使用SSLv23的填充方式</span><br><span class="line">-raw            use no padding                                       //不进行填充</span><br><span class="line">-pkcs           use PKCS<span class="comment">#1 v1.5 padding (default)                    //使用V1.5的填充方式</span></span><br><span class="line">-oaep           use PKCS<span class="comment">#1 OAEP                                      //使用OAEP的填充方式</span></span><br><span class="line">-sign           sign with private key                                //使用私钥做签名</span><br><span class="line">-verify         verify with public key                               //使用公钥认证签名</span><br><span class="line">-encrypt        encrypt with public key                              //使用公钥加密</span><br><span class="line">-decrypt        decrypt with private key                             //使用私钥解密</span><br><span class="line">-hexdump        hex dump output                                      //以16进制dump输出</span><br><span class="line">-engine e       use engine e, possibly a hardware device.            //指定三方库或者硬件设备</span><br><span class="line">-passin arg    pass phrase <span class="built_in">source</span>                                    //指定输入的密码</span><br></pre></td></tr></table></figure>
<ol>
<li><p>使用rsautl进行加密与解密操作（公钥加密，私钥解密）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*生成RSA密钥*&#x2F;</span><br><span class="line">xxx@cmos:~&#x2F;test$ openssl genrsa -des3 -passout pass:123456 -out RSA.pem </span><br><span class="line">Generating RSA private key, 512 bit long modulus</span><br><span class="line">............++++++++++++</span><br><span class="line">...++++++++++++</span><br><span class="line">e is 65537 (0x10001)</span><br><span class="line">&#x2F;*提取公钥*&#x2F;</span><br><span class="line">xxx@cmos:~&#x2F;test$ openssl rsa -in RSA.pem -passin pass:123456 -pubout -out pub.pem </span><br><span class="line">writing RSA key</span><br><span class="line">&#x2F;*使用RSA作为密钥进行加密，实际上使用其中的公钥进行加密*&#x2F;</span><br><span class="line">xxx@cmos:~&#x2F;test$ openssl rsautl -encrypt -in plain.txt -inkey RSA.pem -passin pass:123456 -out enc.txt</span><br><span class="line">&#x2F;*使用RSA作为密钥进行解密，实际上使用其中的私钥进行解密*&#x2F;</span><br><span class="line">xxx@cmos:~&#x2F;test$ openssl rsautl -decrypt -in enc.txt -inkey RSA.pem -passin pass:123456 -out replain.txt</span><br><span class="line">&#x2F;*比较原始文件和解密后文件*&#x2F;</span><br><span class="line">xxx@cmos:~&#x2F;test$ diff plain.txt replain.txt </span><br><span class="line">&#x2F;*使用公钥进行加密*&#x2F;</span><br><span class="line">xxx@cmos:~&#x2F;test$ openssl rsautl -encrypt -in plain.txt -inkey pub.pem -pubin -out enc1.txt</span><br><span class="line">&#x2F;*使用RSA作为密钥进行解密，实际上使用其中的私钥进行解密*&#x2F;</span><br><span class="line">xxx@cmos:~&#x2F;test$ openssl rsautl -decrypt -in enc1.txt -inkey RSA.pem -passin pass:123456 -out replain1.txt</span><br><span class="line">&#x2F;*比较原始文件和解密后文件*&#x2F;</span><br><span class="line">xxx@cmos:~&#x2F;test$ diff plain.txt replain1.txt</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用rsautl进行签名和验证操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*提取PCKS8格式的私钥*&#x2F;</span><br><span class="line">xxx@cmos:~&#x2F;test$ openssl pkcs8 -topk8 -in RSA.pem -passin pass:123456 -out pri.pem -nocrypt</span><br><span class="line">&#x2F;*使用RSA密钥进行签名，实际上使用私钥进行加密*&#x2F;</span><br><span class="line">xxx@cmos:~&#x2F;test$ openssl rsautl -sign -in plain.txt -inkey RSA.pem -passin pass:123456 -out sign.txt</span><br><span class="line">&#x2F;*使用RSA密钥进行验证，实际上使用公钥进行解密*&#x2F;</span><br><span class="line">xxx@cmos:~&#x2F;test$ openssl rsautl -verify -in sign.txt -inkey RSA.pem -passin pass:123456 -out replain.txt</span><br><span class="line">&#x2F;*对比原始文件和签名解密后的文件*&#x2F;</span><br><span class="line">xxx@cmos:~&#x2F;test$ diff plain.txt replain.txt </span><br><span class="line">&#x2F;*使用私钥进行签名*&#x2F;</span><br><span class="line">xxx@cmos:~&#x2F;test$ openssl rsautl -sign -in plain.txt -inkey pri.pem  -out sign1.txt</span><br><span class="line">&#x2F;*使用公钥进行验证*&#x2F;</span><br><span class="line">xxx@cmos:~&#x2F;test$ openssl rsautl -verify -in sign1.txt -inkey pub.pem -pubin -out replain1.txt</span><br><span class="line">&#x2F;*对比原始文件和签名解密后的文件*&#x2F;</span><br><span class="line">xxx@cmos:~&#x2F;test$ cat plain replain1.txt</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这种使用方法其实还是对原文件的加密与解密操作，因为真正的签名与验签过程是需要给源文件进行摘要提取，然后对摘要进行签名，主要通过openssl dgst命令进行。</p>
</li>
</ol>
<h2 id="openssl-dgst签名与验签"><a href="#openssl-dgst签名与验签" class="headerlink" title="openssl dgst签名与验签"></a>openssl dgst签名与验签</h2><p>dgst指令用法介绍如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xxx@cmos:~&#x2F;test$ openssl dgst -</span><br><span class="line">unknown option &#39;-&#39;</span><br><span class="line">options are</span><br><span class="line">-c              to output the digest with separating colons        &#x2F;&#x2F;输出的摘要信息以分号隔离，和-hex同时使用</span><br><span class="line">-r              to output the digest in coreutils format           &#x2F;&#x2F;指定输出的格式</span><br><span class="line">-d              to output debug info                               &#x2F;&#x2F;输出BIO调试信息</span><br><span class="line">-hex            output as hex dump                                 &#x2F;&#x2F;以16进制打印输出结果</span><br><span class="line">-binary         output in binary form                              &#x2F;&#x2F;输出二进制结果</span><br><span class="line">-hmac arg       set the HMAC key to arg                            &#x2F;&#x2F;指定hmac的key</span><br><span class="line">-non-fips-allow allow use of non FIPS digest                       &#x2F;&#x2F;允许使用不符合fips标准的摘要算法</span><br><span class="line">-sign   file    sign digest using private key in file              &#x2F;&#x2F;执行签名操作，后面指定私钥文件</span><br><span class="line">-verify file    verify a signature using public key in file        &#x2F;&#x2F;执行验证操作，后面指定公钥文件，与prverfify不能同时使用</span><br><span class="line">-prverify file  verify a signature using private key in file       &#x2F;&#x2F;执行验证操作，后面指定密钥文件，与verfify不能同时使用</span><br><span class="line">-keyform arg    key file format (PEM or ENGINE)                    &#x2F;&#x2F;指定密钥文件格式，pem或者engine</span><br><span class="line">-out filename   output to filename rather than stdout              &#x2F;&#x2F;指定输出文件，默认标准输出</span><br><span class="line">-signature file signature to verify                                &#x2F;&#x2F;指定签名文件，在验证签名时使用</span><br><span class="line">-sigopt nm:v    signature parameter                                &#x2F;&#x2F;签名参数</span><br><span class="line">-hmac key       create hashed MAC with key                         &#x2F;&#x2F;制作一个hmac 使用key</span><br><span class="line">-mac algorithm  create MAC (not neccessarily HMAC)                 &#x2F;&#x2F;制作一个mac</span><br><span class="line">-macopt nm:v    MAC algorithm parameters or key                    &#x2F;&#x2F;mac算法参数或者key</span><br><span class="line">-engine e       use engine e, possibly a hardware device.          &#x2F;&#x2F;使用硬件或者三方加密库</span><br><span class="line">-md4            to use the md4 message digest algorithm            &#x2F;&#x2F;摘要算法使用md4</span><br><span class="line">-md5            to use the md5 message digest algorithm            &#x2F;&#x2F;摘要算法使用md5</span><br><span class="line">-ripemd160      to use the ripemd160 message digest algorithm      &#x2F;&#x2F;摘要算法使用ripemd160</span><br><span class="line">-sha            to use the sha message digest algorithm            &#x2F;&#x2F;摘要算法使用sha</span><br><span class="line">-sha1           to use the sha1 message digest algorithm           &#x2F;&#x2F;摘要算法使用sha1</span><br><span class="line">-sha224         to use the sha224 message digest algorithm         &#x2F;&#x2F;摘要算法使用sha223</span><br><span class="line">-sha256         to use the sha256 message digest algorithm         &#x2F;&#x2F;摘要算法使用sha256</span><br><span class="line">-sha384         to use the sha384 message digest algorithm         &#x2F;&#x2F;摘要算法使用sha384</span><br><span class="line">-sha512         to use the sha512 message digest algorithm         &#x2F;&#x2F;摘要算法使用sha512</span><br><span class="line">-whirlpool      to use the whirlpool message digest algorithm      &#x2F;&#x2F;摘要算法使用whirlpool</span><br></pre></td></tr></table></figure>
<p>使用RSA密钥进行签名验证操作:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">openssl dgst -sha256 -sign rsa_2048.pem -out stroptr.c.sign stroptr.c  <span class="comment"># 生成摘要签名</span></span><br><span class="line">openssl  dgst  -verify pub.pem -sha256 -signature stroptr.c.sign  stroptr.c <span class="comment"># 验证签名</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>openssl</category>
      </categories>
      <tags>
        <tag>openssl</tag>
      </tags>
  </entry>
  <entry>
    <title>printk_ratelimited 导致log打印不全</title>
    <url>/2020/06/30/printk-ratelimited/</url>
    <content><![CDATA[<p>在Android调试过程中，发现启动log中出现如下log：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[   48.471014] printk: init: 46 output lines suppressed due to ratelimiting</span><br><span class="line">[   48.617226] init: [libfs_mgr]dt_fstab: Skip disabled entry for partition vendor</span><br><span class="line">[   48.631023] init: [libfs_mgr]Warning: unknown flag: wrappedkey</span><br><span class="line">[   48.639762] init: DM_DEV_STATUS failed for system_ext: No such device or address</span><br><span class="line">[   48.647430] init: Could not update logical partition</span><br><span class="line">[   48.653314] init: DM_DEV_STATUS failed for product: No such device or address</span><br><span class="line">[   48.660748] init: Could not update logical partition</span><br></pre></td></tr></table></figure>
<p>也就是说<code>printk: init: 46 output lines suppressed due to ratelimiting</code>有部分log没有打印出来，解决办法就是修改kernel源码。修改文件位于<code>include/linux/ratelimit.h</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 下面表示5秒内最多打印10条记录，可以将DEFAULT_RATELIMIT_BURST修改成50，那么5秒内就可以打印50条了。当然也不是越大越好，因为需要考虑考log对系统服务器的影响，不要引起阻塞。</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFAULT_RATELIMIT_INTERVAL      (5 * HZ)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFAULT_RATELIMIT_BURST         10  <span class="comment">// 可以修改成50</span></span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>kernel</category>
      </categories>
      <tags>
        <tag>kernel</tag>
        <tag>printk</tag>
        <tag>调试</tag>
      </tags>
  </entry>
  <entry>
    <title>匿名命名空间与inline命名空间</title>
    <url>/2020/12/07/unnamed-inline-namespaces/</url>
    <content><![CDATA[<p>c/c++中除了正常使用的命名空间外，还提供了匿名命名空间与inline命名空间，这两种命名空间用在特殊的场合。</p>
<h3 id="匿名命名空间"><a href="#匿名命名空间" class="headerlink" title="匿名命名空间"></a>匿名命名空间</h3><p>匿名命名空间就是在<code>namespace</code>关键字后没有带名字标识符的命名空间，看如下例子。</p>
<a id="more"></a>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> &#123; <span class="comment">// 匿名命名空间</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"v1\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    doSomething();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的例子会正常输出：<br><code>v1</code><br>官方的说法是，所有的匿名命名空间中定义的内容，都会作为其父命名空间的一部分。所以在上面例子中的<code>main</code>函数中可以调用匿名命名空间中的内容，但是在定义该命名空间的文件外<code>doSomething</code>不可见。所以命名空间的作用相同与<code>static</code>作用。</p>
<h3 id="inline命名空间"><a href="#inline命名空间" class="headerlink" title="inline命名空间"></a>inline命名空间</h3><p><code>inline命名空间</code>经常用于对同一函数的多个版本管理。看下面的例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">namespace</span> v1 &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; 'v1\n';</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> v2 &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"v2\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    v1::doSomething(); <span class="comment">// 调用v1命名空间的doSomething()函数</span></span><br><span class="line">    v2::doSomething(); <span class="comment">// 调用v2命名空间的doSomething()函数</span></span><br><span class="line">    doSomething(); <span class="comment">// 调用inline命名空间中的函数v1::doSomething()</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的例子中可以看到，同一文件中，不加命名空间默认调用<code>inline 命名空间</code>中的内容，如果新的版本的函数定义的普通命名空间中，加上命名空间名字调用即可。</p>
]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
      </tags>
  </entry>
  <entry>
    <title>如何解压android系统镜像</title>
    <url>/2020/05/18/unpack-filesystem-data/</url>
    <content><![CDATA[<p>&emsp;&emsp;在android的开发过程中，经常需要用到将andorid system.img 或者 vendor.img等ext文件系统格式的镜像给解压出来分析，如果当前Linux系统有root权限，那么可以直接mount 镜像来进行提取，但是一般开发服务器是不提供root权限的，所以本文讨论如何在没有root权限的情况下对文件系统镜像进行提取。以AndroidQ super.img为例进行说明。</p>
<a id="more"></a>

<h2 id="super-img"><a href="#super-img" class="headerlink" title="super.img"></a>super.img</h2><p>&emsp;&emsp;super.img是AndroidQ引入的，用于处理动态分区特性。例如将system、vendor<br>、product分区定义为动态分区，那么编译完成时这三个分区的镜像就会合并成一个super.img镜像，当然也能将super.img拆分成system.img、vendor.img、product.img镜像。</p>
<h3 id="如何拆分super-img"><a href="#如何拆分super-img" class="headerlink" title="如何拆分super.img"></a>如何拆分super.img</h3><p>&emsp;&emsp;Android Q 自带了lpunpack工具来对super.img进行解压。下面是lpunpack的使用介绍。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./lpunpack - <span class="built_in">command</span>-line tool <span class="keyword">for</span> extracting partition images from super</span><br><span class="line"></span><br><span class="line">Usage:</span><br><span class="line">  ./lpunpack [options...] SUPER_IMAGE [OUTPUT_DIR]</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -p, --partition=NAME     Extract the named partition. This can</span><br><span class="line">                           be specified multiple <span class="built_in">times</span>.</span><br><span class="line">  -S, --slot=NUM           Slot number (default is 0).</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;例如：<code>lpunpack super.img</code>默认会将所有的分区文件提取出来，可以通过-p选择提取指定的分区镜像。需要注意的是，lpunpack工具aosp代码默认不会编译，可以通过将lpunpack加入PRODUCT_HOST_PACKAGES，然后编译，源码在aosp源码的system/extras/partition_tools目录。<br>&emsp;&emsp;aosp源码的system/extras/partition_tools目录下面还有几个常用工具，一起介绍下。<br>lpmake：用于生成一个super.img文件，具体使用方法可以通过<code>lpmake -h</code>查看。<br>lpdump：用于dump一个super.img文件中包含哪些分区等元数据。<br>lpflash：用于烧录镜像到设备，<code>Usage: lpflash /dev/block/sdX /path/to/image/file</code>。</p>
<h2 id="如何拆分system-img"><a href="#如何拆分system-img" class="headerlink" title="如何拆分system.img"></a>如何拆分system.img</h2><p>&emsp;&emsp;通过上个步骤的lpunpack后，会得到system.img.如果system.img镜像的格式是sparse格式的（super.img解压后的不需要这个步骤，已经是raw格式的了），需要将其转换为raw格式，转换工具为<code>simg2img</code>，在aosp编译后的out/host/linux-x86/bin目录，转换命令如下:  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">simg2img system.img  system.img.raw</span><br></pre></td></tr></table></figure>
<p>system.img一般为ext文件系统，这里以ext文件系统解压作为讲解。最常用的方法就是使用e2fsprogs中的debugfs了。比如想将system.img中的内容解压到system目录，使用debugfs的命令如下:  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir system</span><br><span class="line">debugfs system.img  -R <span class="string">"rdump / system"</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;还有一种方法是使用nlitsme提供的extfstools工具，在github上有下载该工具的源码。但是extfstools依赖c++17与boost库，所以需要先编译gcc 6以上的版本与boost库。</p>
<h3 id="编译gcc"><a href="#编译gcc" class="headerlink" title="编译gcc"></a>编译gcc</h3><p>&emsp;&emsp;在gcc 6以上的对c++17的特性支持比较全，关于gcc对c++版本的支持查看<a href="https://zh.cppreference.com/w/cpp/compiler_support" target="_blank" rel="noopener">这里</a>。所以选取了gcc-6.2.0，下载地址点<a href="https://ftp.gnu.org/gnu/gcc/gcc-6.2.0/gcc-6.2.0.tar.bz2" target="_blank" rel="noopener">这里</a>。  </p>
<ol>
<li>配置gcc  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir build install</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">../$(gcc-source-scode-dir)/configure --prefix=&lt;install目录的绝对路径&gt; --<span class="built_in">enable</span>-languages=c,c++</span><br></pre></td></tr></table></figure>
执行上面步骤的时候可能会出现如下报错:  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">checking for objdir... .libs</span><br><span class="line">checking for the correct version of gmp.h... no</span><br><span class="line">configure: error: Building GCC requires GMP 4.2+, MPFR 2.4.0+ and MPC 0.8.0+.</span><br><span class="line">Try the --with-gmp, --with-mpfr and&#x2F;or --with-mpc options to specify</span><br><span class="line">their locations.  Source code for these libraries can be found at</span><br><span class="line">their respective hosting sites as well as at</span><br><span class="line">ftp:&#x2F;&#x2F;gcc.gnu.org&#x2F;pub&#x2F;gcc&#x2F;infrastructure&#x2F;.  See also</span><br><span class="line">http:&#x2F;&#x2F;gcc.gnu.org&#x2F;install&#x2F;prerequisites.html for additional info.  If</span><br><span class="line">you obtained GMP, MPFR and&#x2F;or MPC from a vendor distribution package,</span><br><span class="line">make sure that you have installed both the libraries and the header</span><br><span class="line">files.  They may be located in separate packages.</span><br></pre></td></tr></table></figure>
解决方法是到gcc源码目录执行<code>./contrib/download_prerequisites</code>，然后重新配置gcc。</li>
<li>编译与安装<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make -j32</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="编译boost"><a href="#编译boost" class="headerlink" title="编译boost"></a>编译boost</h3><p>&emsp;&emsp;boost的新版本下载地址请点击<a href="https://dl.bintray.com/boostorg/release/1.73.0/source/boost_1_73_0.tar.bz2" target="_blank" rel="noopener">这里</a>。关于新手怎么使用boost可以查看<a href="https://www.boost.org/doc/libs/1_73_0/more/getting_started/unix-variants.html" target="_blank" rel="noopener">官方文档</a>。</p>
<ol>
<li>配置boost  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> &lt;bost_source_dir&gt;</span><br><span class="line">mkdir install</span><br><span class="line">./bootstrap.sh --with-toolset=gcc --prefix=&lt;Absolute address <span class="keyword">for</span> bost_source_dir&gt;/install --with-libraries=all</span><br></pre></td></tr></table></figure></li>
<li>编译与安装  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./b2 install</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="编译extfstools"><a href="#编译extfstools" class="headerlink" title="编译extfstools"></a>编译extfstools</h3><p>&emsp;&emsp;extfstools可以通过git命令从github<a href="https://github.com/nlitsme/extfstools.git" target="_blank" rel="noopener">地址</a>下载。由于我们的gcc与boost是安装的自定义目录，没有安装到系统目录，所以需要修改extfstools/Makefile来指定环境变量。在<code>CXXFLAGS</code>中加入<code>-I &lt;Absolute address for bost_source_dir&gt;/install/include</code>,在<code>LDFLAGS</code>中添加<code>-Wl,-rpath,&#39;$$ORIGIN/lib64&#39;</code>。这里修改链接选项的目的是使用我们新编译的gcc库。  </p>
<ol>
<li><p>拷贝gcc标准库  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> &lt;extfstools <span class="built_in">source</span> dir&gt;</span><br><span class="line">mkdir lib64</span><br><span class="line"><span class="built_in">cd</span> lib64</span><br><span class="line">cp &lt;gcc install path&gt;/libgcc_s.so.1 libgcc_s.so.1</span><br><span class="line">cp &lt;gcc install path&gt;/libstdc++.so.6.0.22 libstdc++.so.6.0.22</span><br><span class="line">ln -s libstdc++.so.6.0.22 libstdc++.so.6</span><br><span class="line"><span class="built_in">cd</span> -</span><br></pre></td></tr></table></figure>
</li>
<li><p>编译  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CXX=&lt;gcc install path&gt;/g++ make clean</span><br><span class="line">CXX=&lt;gcc install path&gt;/g++ make -j32</span><br></pre></td></tr></table></figure>
<p>编译完成后，执行<code>./ext2rd --help</code>会打印如果使用说明：<br><img src="/images/ext2rd_help.png" alt=""><br>解压system.img:  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./ext2rd system.img  ./:system</span><br></pre></td></tr></table></figure>
<p>解压效果如下图:<br><img src="/images/system_filelist.png" alt=""></p>
</li>
</ol>
]]></content>
      <categories>
        <category>android</category>
        <category>filesystem</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>filesystem</tag>
      </tags>
  </entry>
  <entry>
    <title>引用变量</title>
    <url>/2021/01/13/reference-varaibles/</url>
    <content><![CDATA[<p>引用变量是c++的基本变量。用于给其它变量或对象定义别名。c++支持三种类型的引用变量：</p>
<ol>
<li>非const变量的引用</li>
<li>const变量的引用</li>
<li>在c++11中引入的右值(r-value)的引用<a id="more"></a>

</li>
</ol>
<h4 id="非const变量的引用"><a href="#非const变量的引用" class="headerlink" title="非const变量的引用"></a>非const变量的引用</h4><p>一个非const变量的引用通过<code>&amp;</code>符号来进行申明。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> value&#123;<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> &amp;ref&#123;value&#125;;</span><br></pre></td></tr></table></figure>
<p>上面的语法中，<code>&amp;</code>不表示取地址，而是表示<code>引用</code>。非常量值的引用通常简称为<code>引用</code>。跟指针语法中的<code>*</code>符号使用一样，<code>&amp;</code>不论是靠近类型名还是引用变量名都是可以的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这两个语法是一样的</span></span><br><span class="line"><span class="keyword">int</span> &amp;ref1&#123;value&#125;;</span><br><span class="line"><span class="keyword">int</span>&amp; ref2&#123;value&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="引用变量作为别名"><a href="#引用变量作为别名" class="headerlink" title="引用变量作为别名"></a>引用变量作为别名</h4><p>引用变量通常表示它所引用的变量的值。在这种情况下，引用变量就是一个别名。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x&#123;<span class="number">5</span>&#125;; <span class="comment">// 普通变量</span></span><br><span class="line"><span class="keyword">int</span> &amp;y&#123;x&#125;; <span class="comment">// y是x的引用</span></span><br><span class="line"><span class="keyword">int</span> &amp;z&#123;y&#125;; <span class="comment">// z是y的引用</span></span><br></pre></td></tr></table></figure>
<p>在上面的代码片段中，对x、y、z三个变量的赋值或者取值都是一样的。下面是引用变量的使用的例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value&#123;<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> &amp;ref&#123;vaule&#125;;</span><br><span class="line"></span><br><span class="line">    value = <span class="number">6</span>; <span class="comment">// value=ref=6</span></span><br><span class="line">    ref = <span class="number">7</span>; <span class="comment">// vaule=refs=7</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; value &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// prints 7</span></span><br><span class="line">    ref++;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; value &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// prints 8</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上面的代码运行过程可以知道，<code>ref</code>就是<code>value</code>的别名。可以通过如下代码知道他们其实是指向相同的地址的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; &amp;erf;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; &amp;value;</span><br></pre></td></tr></table></figure>
<h4 id="左值与右值"><a href="#左值与右值" class="headerlink" title="左值与右值"></a>左值与右值</h4><p>在c++中，变量是左值类型。一个左值，它的值在内存中拥有一个地址。因为所有变量都有地址，所以所有变量都是左值。左值之所以叫做左值，是因为它是唯一一个能够存在于赋值语句左侧的值。所以在赋值语句中，<code>=</code>号左侧需要时一个左值。<code>5 = 6;</code>会报错，因为<code>5</code>不是左值（5没有内存地址）。当一个左值被赋值的时候，左值对应地址的值会被修改。<br>于左值相对应的就是右值。右值是一个非左值表达式，例如数字<code>5</code>与非右值表达式<code>2 + x</code>。下面是一些赋值语句的例子，展示了右值是如果evaluate(估值)的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> y;</span><br><span class="line">y = <span class="number">4</span>;      <span class="comment">// 4是右值，它被估值为4 然后赋值给左值y</span></span><br><span class="line">y = <span class="number">2</span> + <span class="number">5</span>;  <span class="comment">// 2 + 5 是右值，它被赋值为7， 然后赋值给左值y</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line">x = y;  <span class="comment">// 这种情况下，y是右值，他被估值为7，然后赋值给左值x</span></span><br><span class="line">x = x;  <span class="comment">// 右边的x是右值，它被估值为7，然后赋值给左值x</span></span><br><span class="line">x = x + <span class="number">1</span>; <span class="comment">// 同上</span></span><br></pre></td></tr></table></figure>
<p>从上面的代码片段可以知道，一个变量在不同的语境的既可能作为右值也可能作为左值。</p>
<h4 id="引用变量必须初始化"><a href="#引用变量必须初始化" class="headerlink" title="引用变量必须初始化"></a>引用变量必须初始化</h4><p>引用变量必须在创建时初始化：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> value&#123;<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> &amp;ref&#123;value&#125;; <span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">int</span> &amp;invalidRef; <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure>
<p>跟指针不一样，指针可以保存一个空指针，但是没有一个引用是空引用。非const变量的引用不能被初始化为对const变量的引用，同时也不能被初始化为对一个右值的引用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x&#123;<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> &amp;ref1&#123;x&#125;; <span class="comment">// 正确</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> y&#123;<span class="number">7</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> &amp;ref2&#123;y&#125;; <span class="comment">// 错误</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> &amp;ref3&#123;<span class="number">7</span>&#125;; <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure>

<h4 id="引用变量不能被重新赋值"><a href="#引用变量不能被重新赋值" class="headerlink" title="引用变量不能被重新赋值"></a>引用变量不能被重新赋值</h4><p>引用变量已经初始化，就不能被再次赋值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> value1&#123;<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> value2&#123;<span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> &amp;ref&#123;vaule1&#125;;</span><br><span class="line">ref = value2;  <span class="comment">// 这里不是将ref重新赋值为对value2的引用，而是将value2的值赋值给ref，所以ref = value1 = 6</span></span><br></pre></td></tr></table></figure>

<h4 id="引用作为函数参数"><a href="#引用作为函数参数" class="headerlink" title="引用作为函数参数"></a>引用作为函数参数</h4><p>引用作为函数参数是相对于c来说的一个重要应用了。在引用作为函数参数的情况下，引用就是参数的别名，所以在调用的时候形参名其实就是实参的别名，不存在将实参的值拷贝到形参中。所以这种使用方法提高了程序的性能。使用引用作为函数参数，跟使用指针作为函数参数类似，不过使用引用作为函数参数更易于理解。<br>在引用作为函数参数的情况下，形参是实参的别名，所以修改形参的值就修改了实参的值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">changN</span><span class="params">(<span class="keyword">int</span> &amp;value)</span> </span>&#123;</span><br><span class="line">    value = <span class="number">6</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">9</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="string">'\n'</span>;  <span class="comment">// prints 9</span></span><br><span class="line"></span><br><span class="line">    changN(n);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="string">'\n'</span>;  <span class="comment">// prints 6</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以，当函数需要修改实参的值的时候，可以使用非const引用变量作为函数的参数。</p>
<h4 id="数组引用作为函数参数"><a href="#数组引用作为函数参数" class="headerlink" title="数组引用作为函数参数"></a>数组引用作为函数参数</h4><p>在c语言中，一般传入数组名或者指针作为函数的参数，这样形参就变成了指针了，对数组长度是无法获取的，c中的做法一般是在传入指针的同时将长度也传入函数。但是如果使用数组的引用作为函数参数，就不会有这个问题。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">/* 注意使用数组引用作为函数参数时，需要指定数组长度 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printElements</span><span class="params">(<span class="keyword">int</span> &amp;<span class="built_in">array</span>[<span class="number">5</span>])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length&#123;<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="built_in">std</span>::<span class="built_in">size</span>(<span class="built_in">array</span>))&#125;; <span class="comment">// 注意std::size需要c++17的支持</span></span><br><span class="line">    <span class="comment">// int length&#123;sizeof(array)/sizeof(array[0])&#125;;  // 不支持c++17时用这个</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i&#123;<span class="number">0</span>&#125;; i&lt;length; i++) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">array</span>[i] &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[]&#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>&#125;;</span><br><span class="line">    printElements(arr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h4 id="使用引用快捷访问内部成员"><a href="#使用引用快捷访问内部成员" class="headerlink" title="使用引用快捷访问内部成员"></a>使用引用快捷访问内部成员</h4><p>引用还有一个应用的比较少的场景是对对象内部成员的引用。看下面的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Something</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> value1;</span><br><span class="line">    <span class="keyword">float</span> value2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">Other</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Something something;</span><br><span class="line">    <span class="keyword">int</span> othervalue;</span><br><span class="line">&#125;;</span><br><span class="line">Other other;</span><br></pre></td></tr></table></figure>
<p>当在<code>other</code>中，需要访问<code>something</code>成员的<code>value1</code>时，需要通过<code>other.something.value1</code>来访问，如果成员嵌套的足够深，那么代码就显得冗余了。引用使得在这种情况下，访问内嵌成员更简单：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp;ref&#123;other.something.value1&#125;;</span><br><span class="line">ref = <span class="number">5</span>; <span class="comment">// 跟 other.something.value1 = 5; 效果一样</span></span><br></pre></td></tr></table></figure>
<p>不过，这种情况下使用引用可能使得程序可读性变差，具体应用根据场景决定。</p>
<h4 id="引用-vs-指针"><a href="#引用-vs-指针" class="headerlink" title="引用 vs 指针"></a>引用 vs 指针</h4><p>引用其实是在编译器内部通过指针来实现的，一般就是一个常量指针。使用引用的情况程序可读性要好一些。因为引用在申明的时候就必须显示初始化（不能初始化为null），并且只能初始化一次，所以安全性要比指针高。<code>如果给定任务可以通过引用或指针解决，则通常应首选引用。 指针仅应在引用不足以应付的情况下使用（例如，动态分配内存）。</code></p>
<h4 id="常量引用"><a href="#常量引用" class="headerlink" title="常量引用"></a>常量引用</h4><p>常量引用通常用于函数参数，因为传入后不能修改实参，所以更安全。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printIt</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a&#123; <span class="number">1</span> &#125;;</span><br><span class="line">    printIt(a); <span class="comment">// non-const l-value</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> b&#123; <span class="number">2</span> &#125;;</span><br><span class="line">    printIt(b); <span class="comment">// const l-value</span></span><br><span class="line"> </span><br><span class="line">    printIt(<span class="number">3</span>); <span class="comment">// literal r-value</span></span><br><span class="line"> </span><br><span class="line">    printIt(<span class="number">2</span>+b); <span class="comment">// expression r-value</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：当使用引用作为函数参数时，如果参数是非指针类型或者非基本数据类型(int,float…)时，使用常量引用。</p>
]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
      </tags>
  </entry>
</search>
