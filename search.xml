<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>如何在EDK II中编写应用程序</title>
    <url>/2020/05/25/EDK2-new-app/</url>
    <content><![CDATA[<p>EDK2的开发一般分为驱动与应用的开发，本文介绍如何在EDK2中开发应用程序。官方的教程请参考：<a href="https://github.com/tianocore/tianocore.github.io/wiki/Getting-Started-Writing-Simple-Application" target="_blank" rel="noopener">Getting Started Writing Simple Application</a>。</p>
<h3 id="如何编写C文件"><a href="#如何编写C文件" class="headerlink" title="如何编写C文件"></a>如何编写C文件</h3><p><code>https://github.com/tianocore/tianocore.github.io/wiki/Getting-Started-Writing-MyHelloWorld.c</code></p>
<h3 id="如何编写inf文件"><a href="#如何编写inf文件" class="headerlink" title="如何编写inf文件"></a>如何编写inf文件</h3><h4 id="如何生成GUID"><a href="#如何生成GUID" class="headerlink" title="如何生成GUID"></a>如何生成GUID</h4><p>通过<a href="https://www.guidgen.com/" target="_blank" rel="noopener">guidgen网站</a>生成GUID。</p>
]]></content>
      <tags>
        <tag>EDK2 EDKii EDK II</tag>
      </tags>
  </entry>
  <entry>
    <title>android simpleperf工具使用入门</title>
    <url>/2020/05/15/android-simpleperf/</url>
    <content><![CDATA[<p>&emsp;&emsp;Simpleperf 是一个通用的命令行 CPU 性能剖析工具，在Android NDK中已经自带了。需要注意的是，如果自带的simpleperf不能使用，就需要在适配当前Android设备的源码中编译了。simpleperf的源码在AOSP的system/extras/simpleperf下，其中doc目录详细介绍了如何使用该工具。</p>
<a id="more"></a>

<h2 id="在源码中编译simpleperf"><a href="#在源码中编译simpleperf" class="headerlink" title="在源码中编译simpleperf"></a>在源码中编译simpleperf</h2><p>&emsp;&emsp;可以通过如下命令在Andorid设备的源码中编译simpleperf:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> build/envsetup.sh</span><br><span class="line">lunch aosp_arm64-eng</span><br><span class="line">make simpleperf -j32</span><br></pre></td></tr></table></figure>
<p>最后将会生成out/target/product/xxx/system/xbin/simpleperf，这就是需要push到Android设备的simpleperf。</p>
<h3 id="push-simpleperf"><a href="#push-simpleperf" class="headerlink" title="push simpleperf"></a>push simpleperf</h3><p>&emsp;&emsp;在push之前需要需要保证Android设备具有root权限，一般通过adb root选项进行提权。然后通过如下命令将simpleperf push到设备。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">adb root</span><br><span class="line">adb shell mkdir /data/bin</span><br><span class="line">adb push &lt;编译出来的simpleperf&gt; /data/bin/simpleperf</span><br><span class="line">adb shell setenforce 0</span><br></pre></td></tr></table></figure>
<p>进行了上述步骤后，就可以在设备中使用simpleperf了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">adb shell /data/bin/simpleperf --version</span><br><span class="line"><span class="comment"># simpleperf I command.cpp:131] Simpleperf version 1.c65e6065befd</span></span><br><span class="line"><span class="comment">#</span></span><br></pre></td></tr></table></figure>

<h2 id="simpleperf使用介绍"><a href="#simpleperf使用介绍" class="headerlink" title="simpleperf使用介绍"></a>simpleperf使用介绍</h2><p>&emsp;&emsp;simpleperf的record命令用于转储已需要分析的进程的样本。 每个样本可以包含诸如样本生成时间，自上一个样本以来的事件数，线程的程序计数器，线程的调用链之类的信息。后续的分析步骤都是基于这个样本信息来分析的。</p>
<h3 id="采集样本数据"><a href="#采集样本数据" class="headerlink" title="采集样本数据"></a>采集样本数据</h3><p>首先确认需要分析的进程。比如分析当前cpu占用最高的进程。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">top -m 5 <span class="comment"># 得到执行的进程名字</span></span><br><span class="line"><span class="comment">## 根据pidof得到需要分析的进程id号</span></span><br><span class="line">pidof &lt;进程名&gt;</span><br></pre></td></tr></table></figure>
<p>得到进程id后就可以进行数据采集了。如果使用simpleperf的recod命令请参<a href="https://android.googlesource.com/platform/system/extras/+/refs/heads/master/simpleperf/doc/executable_commands_reference.md" target="_blank" rel="noopener">考官方文档</a>中的<code>The record command</code>小节。<br>如下的命令记录进行号为11961的record：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/data/bin/simpleperf record -p 11961 -o /sdcard/perf_11961.data --duration 360</span><br></pre></td></tr></table></figure>
<p>结果保存在/sdcard/perf_11961.data,记录持续时间为360秒。这里只记录了默认的<code>cpu-cycles</code>event，如果需要记录更加多的event需要指定-e参数。通过<code>simpleperf list</code>命令查看支持哪些events。</p>
<h3 id="查看特定进程调用的动态库"><a href="#查看特定进程调用的动态库" class="headerlink" title="查看特定进程调用的动态库"></a>查看特定进程调用的动态库</h3><p>通过report命令可以查看这种report数据：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./simpleperf report --sort dso -i /sdcard/perf_11961.data</span><br><span class="line">simpleperf W dso.cpp:361] failed to <span class="built_in">read</span> symbols from [vdso]: File not found</span><br><span class="line">Cmdline: /data/bin/simpleperf record -p 11961 -o /sdcard/perf_11961.data --duration 360</span><br><span class="line">Arch: arm64</span><br><span class="line">Event: cpu-cycles (<span class="built_in">type</span> 0, config 0)</span><br><span class="line">Samples: 649</span><br><span class="line">Event count: 136430910</span><br><span class="line"></span><br><span class="line">Overhead  Shared Object</span><br><span class="line">57.91%    [kernel.kallsyms]</span><br><span class="line">20.03%    /system/lib64/libart.so</span><br><span class="line">9.43%     /system/lib64/libandroidfw.so</span><br><span class="line">5.05%     /system/framework/arm64/boot-framework.oat</span><br><span class="line">3.58%     /system/lib64/libc.so</span><br><span class="line">1.67%     /system/framework/arm64/boot-core-oj.oat</span><br><span class="line">0.89%     /system/lib64/libbinder.so</span><br><span class="line">0.39%     /system/lib64/libc++.so</span><br><span class="line">0.38%     /system/lib64/libopenjdk.so</span><br><span class="line">0.27%     /system/lib64/libz.so</span><br><span class="line">0.15%     /system/lib64/libandroid_runtime.so</span><br><span class="line">0.13%     [vdso]</span><br><span class="line">0.07%     /system/framework/arm64/boot-core-libart.oat</span><br><span class="line">0.05%     /system/lib64/libutils.so</span><br></pre></td></tr></table></figure>

<h3 id="查看函数调用关系"><a href="#查看函数调用关系" class="headerlink" title="查看函数调用关系"></a>查看函数调用关系</h3><p>simpleperf report还可以导出函数调用关系,–symfs可以指定符号表的目录。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/data/bin/simpleperf report -g  -i /sdcard/perf_19357.data --symfs . &gt; /sdcard/g_19357.dat</span><br></pre></td></tr></table></figure>

<h4 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h4><ol>
<li><a href="https://blog.csdn.net/zhuyong006/article/details/103112571" target="_blank" rel="noopener">https://blog.csdn.net/zhuyong006/article/details/103112571</a></li>
<li><a href="https://developer.android.com/ndk/guides/simpleperf" target="_blank" rel="noopener">https://developer.android.com/ndk/guides/simpleperf</a></li>
</ol>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>android逆向学习计划</title>
    <url>/2020/07/22/android-reverse-engineering-plan/</url>
    <content><![CDATA[<p>参考<a href="https://zhuanlan.zhihu.com/p/101396731" target="_blank" rel="noopener">如何系统的学习安卓逆向</a>,制定如下学习计划。</p>
<h2 id="一-安卓逆向基础（建议1周）"><a href="#一-安卓逆向基础（建议1周）" class="headerlink" title="一. 安卓逆向基础（建议1周）"></a>一. 安卓逆向基础（建议1周）</h2><ol>
<li>学习安卓逆向第一步必须先把环境搭建好，这是你学习安卓逆向的开始，环境搭建好后表示正式迈入安卓逆向。在环境安装的工程中会遇到很多细节上的问题，针对这些坑可以去看看使用教程，或者看看网课老师的教程操作都可以。</li>
<li>第二步就是要了解我们要分析的是什么文件，很多0基础的都不知道安卓逆向分析的什么文件。我们要分析的是应用程序或者安装包（就是.apk文件），了解apk是怎么生成的以及如何安装到我们的手机里面，apk是怎么运行的，也是我们探讨的内容。</li>
<li>第三步如何逆向分析.apk文件，掌握apk反编译及回编译，完成这个操作使用的工具是apktool。<a id="more"></a>

</li>
</ol>
<h2 id="二-Java层逆向（建议3周）"><a href="#二-Java层逆向（建议3周）" class="headerlink" title="二. Java层逆向（建议3周）"></a>二. Java层逆向（建议3周）</h2><ol>
<li>掌握Java语法基础，达到能看懂Java代码。</li>
<li>了解smali语法，能看懂smali代码。</li>
<li>掌握逆向分析apk中常用的方法和技巧。</li>
</ol>
<h2 id="三-Native层逆向（建议4周）"><a href="#三-Native层逆向（建议4周）" class="headerlink" title="三. Native层逆向（建议4周）"></a>三. Native层逆向（建议4周）</h2><ol>
<li>了解安卓操作系统和四大组件。</li>
<li>了解NDK开发流程，自己编写案例练习。</li>
<li>掌握常用ARM汇编指令，达到能看懂ARM汇编指令。</li>
<li>掌握ida工具的使用，熟练使用ida进行各种操作。</li>
</ol>
<h2 id="四-APK保护策略（建议1周）"><a href="#四-APK保护策略（建议1周）" class="headerlink" title="四. APK保护策略（建议1周）"></a>四. APK保护策略（建议1周）</h2><ol>
<li>了解Java代码混淆、资源混淆。</li>
<li>掌握签名验证、文件校验、模拟器检测。</li>
<li>本地验证、网络验证。</li>
<li>案例练习。</li>
</ol>
<h2 id="五-反调试与反-反调试（建议1周）"><a href="#五-反调试与反-反调试（建议1周）" class="headerlink" title="五. 反调试与反-反调试（建议1周）"></a>五. 反调试与反-反调试（建议1周）</h2><ol>
<li>掌握常用反调试方法及过反调试技巧，比如关键文件检测、调试端口检测、进程名称检测、防附加、轮训检测TracerPid值、时间检测、信号检测等反调试。</li>
<li>掌握IDA过反调试思路。</li>
<li>案例练习。</li>
</ol>
<h2 id="六-HOOK框架（建议2周）"><a href="#六-HOOK框架（建议2周）" class="headerlink" title="六. HOOK框架（建议2周）"></a>六. HOOK框架（建议2周）</h2><ol>
<li>掌握HOOK插件开发。</li>
<li>掌握Xposed、Substrate、Fridad等框架。</li>
<li>案例练习。</li>
</ol>
<h2 id="七-常见加密算法（建议2周）"><a href="#七-常见加密算法（建议2周）" class="headerlink" title="七. 常见加密算法（建议2周）"></a>七. 常见加密算法（建议2周）</h2><ol>
<li>掌握编码算法、消息摘要算法、对称加密算法（Java加密与解密的艺术）。</li>
<li>掌握非对称加密算法、数字签名算法。</li>
</ol>
<h2 id="八-协议加解密分析（建议4周）"><a href="#八-协议加解密分析（建议4周）" class="headerlink" title="八. 协议加解密分析（建议4周）"></a>八. 协议加解密分析（建议4周）</h2><ol>
<li>了解客户端与服务器如何进行交互的（OSI模型、TCP/IP模型）。</li>
<li>掌握常用的抓包工具及环境配置，HTTP协议与HTTPS安全协议，数字证书、SSL证书检测（计算机网络与通信、信息安全工程师）。</li>
<li>案例练习。</li>
</ol>
<h2 id="九-文件结构（建议2周）"><a href="#九-文件结构（建议2周）" class="headerlink" title="九. 文件结构（建议2周）"></a>九. 文件结构（建议2周）</h2><ol>
<li>掌握DEX、ELF、XML、ARSC等文件结构。</li>
<li>自编写文件解析工具。</li>
</ol>
<h2 id="十-系统源码分析（建议2周）"><a href="#十-系统源码分析（建议2周）" class="headerlink" title="十. 系统源码分析（建议2周）"></a>十. 系统源码分析（建议2周）</h2><ol>
<li>了解安卓操作系统启动流程、Zygote启动流程。</li>
<li>掌握Dalvik虚拟机、ART虚拟机、SO加载流程。</li>
</ol>
<h2 id="十一-加固与脱壳（建议4周）"><a href="#十一-加固与脱壳（建议4周）" class="headerlink" title="十一. 加固与脱壳（建议4周）"></a>十一. 加固与脱壳（建议4周）</h2><ol>
<li>了解Dex文件整体加密、Dex代码抽取加密。</li>
<li>了解so文件整体加密、函数加密、区段加密、加壳、混淆。</li>
<li>分析通用脱壳机的实现原理及应用场景。</li>
<li>了解主流加固特点及对应的脱壳技巧。</li>
</ol>
<h2 id="十二-学习方法"><a href="#十二-学习方法" class="headerlink" title="十二. 学习方法"></a>十二. 学习方法</h2><ol>
<li>看一遍教程后自己实战操作，养成做笔记的习惯。</li>
<li>注重基础，一定要把Java层和Native层搞懂。</li>
<li>学习中不要纠结细节，要学会抓大放小。</li>
<li>学完后自己画脑图，回顾学习的过程中那些不理解在花时间去看，此过程就是查漏补缺。</li>
</ol>
]]></content>
      <tags>
        <tag>android逆向</tag>
      </tags>
  </entry>
  <entry>
    <title>c/c++ 变量</title>
    <url>/2020/12/04/c-cpp-variable/</url>
    <content><![CDATA[<h3 id="关于c-c-变量溢出问题"><a href="#关于c-c-变量溢出问题" class="headerlink" title="关于c/c++变量溢出问题"></a>关于c/c++变量溢出问题</h3><ol>
<li><p>无符号变量溢出<br>无符号变量没有负数，只有正数。例如：unsigned char var = 280;其实际值为280%256=24。</p>
</li>
<li><p>有符号变量溢出<br>有符号数最高位表示符号位，1为负数，0为正数。例如：unsigned char var = 128,溢出了，最高为1，所以为负数，根据负数为反码+1，可以知道实际值为-128。</p>
<a id="more"></a>

</li>
</ol>
<h3 id="关于c-c-变量，不同平台或者架构int变量size不一样问题"><a href="#关于c-c-变量，不同平台或者架构int变量size不一样问题" class="headerlink" title="关于c/c++变量，不同平台或者架构int变量size不一样问题"></a>关于c/c++变量，不同平台或者架构int变量size不一样问题</h3><ol>
<li>在不同的平台或者编译器中，标准类型int所占用的size可能不一样，为了解决这给问题，C99中引入了<code>stdint.h</code>头文件来定义指定宽度类型。如:<code>std::int8_t</code>、<code>std::uint8_t</code>、<code>std::uint16_t</code>、<code>std::int32_t</code>、<code>std::int64_t</code>等。所以在C中可以通过引入<code>stdint.h</code>来使用这些类型。在C++11中，这些类型被纳入到<code>cstdint</code>头文件中。<br>使用如上头文件的时候，需要注意，可能某些平台并不支持，所以在代码可移植性方面较差。</li>
<li>c++标准定义的类型(实际使用中，推荐用该方法，因为他是安全的)<br>std::int_fast8_t<br>std::int_fast32_t<br>std::uint_fast16_t<br>std::int_least8_t<br>std::uint_least16_t<br>std::int_least_64_t</li>
</ol>
<h3 id="constexpr关键字"><a href="#constexpr关键字" class="headerlink" title="constexpr关键字"></a>constexpr关键字</h3><p><code>constexpr</code>关键字是C++11中引入的关键字，用于申明常量的值需要在编译时确定。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> a =<span class="number">25</span>; <span class="comment">// ok</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> sum&#123;<span class="number">4</span>+<span class="number">11</span>&#125;; <span class="comment">// ok</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> var; <span class="comment">// not okay</span></span><br></pre></td></tr></table></figure>

<h3 id="关于全局变量与局部变量"><a href="#关于全局变量与局部变量" class="headerlink" title="关于全局变量与局部变量"></a>关于全局变量与局部变量</h3><ol>
<li>同名局部变量在其作用域内会屏蔽全局变量，也就是局部变量会被优先使用<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> Var = <span class="number">9</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Var = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Var = "</span> &lt;&lt; Var &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
上面的程序运行结果为<code>Var = 2</code>。在C++中可以通过范围运算符<code>::</code>来指定使用全局变量。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> Var = <span class="number">9</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Var = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Var = "</span> &lt;&lt; ::Var &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
上面的程序运行结果为<code>Var = 9</code>。</li>
</ol>
<h3 id="关于C-17中的inline-variables"><a href="#关于C-17中的inline-variables" class="headerlink" title="关于C++17中的inline variables"></a>关于C++17中的<code>inline variables</code></h3><p>c++17中为变量引入了<code>inline variable</code>类型。<code>inline variable</code>允许在多个文件中定义，而不会违反编译检查规则，当在多个文件中定义了同名的<code>inline variable</code>时，编译器在编译时将所有的同名<code>inline variables</code>实例化为一个变量。请看如下例子中的使用：<br>constants.h:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONSTANTS_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONSTANTS_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> constants &#123;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">constexpr</span> <span class="keyword">double</span> pi &#123;<span class="number">3.14159</span>&#125;;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">constexpr</span> <span class="keyword">double</span> avogadro &#123;<span class="number">6.022141</span>&#125;;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">constexpr</span> <span class="keyword">double</span> gravity &#123;<span class="number">9.2</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>main.cpp:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"constants.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter a radius: "</span>;</span><br><span class="line">    <span class="keyword">int</span> radius;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; radius;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The circumference is: "</span> &lt;&lt; <span class="number">2.0</span> * radius * constants::pi &lt;&lt; <span class="string">'\n'</span>; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="c-中别名与typedef"><a href="#c-中别名与typedef" class="headerlink" title="c++中别名与typedef"></a>c++中别名与typedef</h3><p>typedef 用法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// typedef 定义的别名应该在后面加上`_t`，表面它是一个类型而不是变量</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Score_t;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span>* Pint_t;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">float</span> <span class="keyword">distance_t</span>;</span><br></pre></td></tr></table></figure>
<p>别名的用法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">score_t</span> = <span class="keyword">int</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">distance_t</span> = <span class="keyword">float</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">pairlist_t</span> = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">int</span>&gt;&gt;;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>c++ iterators</title>
    <url>/2021/01/14/cpp-iterators/</url>
    <content><![CDATA[<p>c++迭代器是一个对象，用于遍历容器中的每个元素。一个容器可能提供多种迭代器。例如，一个array 容器可能提供一个正向的迭代器，用于正向顺序遍历，另外提供一个反向的迭代器，用于反向遍历。一旦创建了合适类型的迭代器，程序员就可以使用迭代器提供的接口来遍历或者访问元素，而不用关注当前使用的是哪种遍历方式，也不用关注容器中存储的是哪种类型的数据。而且由于c++迭代器通常使用相同的接口进行遍历(使用++操作符访问下一个元素)和访问(使用*操作符访问当前元素)，所以可以使用一致的方法编译不同类型的容器。</p>
<h4 id="指针与迭代器"><a href="#指针与迭代器" class="headerlink" title="指针与迭代器"></a>指针与迭代器</h4><p>最简单的迭代器是指针，该指针（使用指针运算）适用于顺序存储在内存中的数据。 下面是一个简单数组遍历的例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">array</span> data&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> <span class="built_in">begin</span>&#123;&amp;data[<span class="number">0</span>]&#125;;</span><br><span class="line">    <span class="keyword">auto</span> <span class="built_in">end</span>&#123;<span class="built_in">begin</span> + <span class="built_in">std</span>::<span class="built_in">size</span>(data)&#125;;</span><br><span class="line">    <span class="comment">// auto end&#123;begin + sizeof(data)/sizeof(data[0])&#125;;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> ptr&#123;<span class="built_in">begin</span>&#125;; ptr != <span class="built_in">end</span>; ptr++) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *ptr &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的例子可以总结出，如果需要遍历那么需要四个要素：</p>
<ol>
<li>开始位置<code>begin</code></li>
<li>结束位置<code>end</code></li>
<li>如果移动到一个位置<code>++操作符</code></li>
<li>获取当前元素的值<code>*操作符</code><br>迭代器在c++标准库算法中应用非常广泛，后续章节将介绍几个常用的算法作用在迭代器上的情况。</li>
</ol>
<h4 id="TODO-标准库算法与迭代器"><a href="#TODO-标准库算法与迭代器" class="headerlink" title="TODO:: 标准库算法与迭代器"></a>TODO:: 标准库算法与迭代器</h4>]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp_ofstream_ifstream</title>
    <url>/2020/08/20/cpp-ofstream-ifstream/</url>
    <content><![CDATA[<p>ofstream是从内存到硬盘，ifstream是从硬盘到内存，其实所谓的流缓冲就是内存空间。<br>在C++中，有一个stream这个类，所有的I/O都以这个“流”类为基础的，包括我们要认识的文件I/O。<br>stream这个类有两个重要的运算符：<br>1、插入器(&lt;&lt;)<br>向流输出数据。比如说系统有一个默认的标准输出流(cout)，一般情况下就是指的显示器，所以，cout&lt;&lt;”Write Stdout”&lt;&lt;’\n’;就表示把字符串”Write Stdout”和换行字符(‘\n’)输出到标准输出流。<br>2、析取器(&gt;&gt;)<br>从流中输入数据。比如说系统有一个默认的标准输入流(cin)，一般情况下就是指的键盘，所以，cin&gt;&gt;x;就表示从标准输入流中读取一个指定类型的数据。<br>在C++中，对文件的操作是通过stream的子类fstream(file stream)来实现的，所以，要用这种方式操作文件，就必须加入头文件fstream.h。</p>
<p>特别提出的是，fstream有两个子类：ifstream(input file stream)和ofstream(outpu file stream)，ifstream默认以输入方式打开文件，ofstream默认以输出方式打开文件。</p>
]]></content>
      <tags>
        <tag>c++ ofstream ifstream</tag>
      </tags>
  </entry>
  <entry>
    <title>脱机安装cx_oracle</title>
    <url>/2020/12/15/cx-oracle-install/</url>
    <content><![CDATA[<p>当服务器没有root权限的时候，安装某些Python模块就不方便了，该文章记录下，当没有root权限时，本地安装Python第三方模块的临时办法，以<code>cx_Oracle</code>模块进行说明。<br>###准备工作<br>在安装<code>cx_Oracle</code>之前，服务器是需要安装<code>basic packages</code>与<code>Development and Runtime packages</code>，下载网址为：<a href="https://www.oracle.com/database/technologies/instant-client/linux-x86-64-downloads.html。" target="_blank" rel="noopener">https://www.oracle.com/database/technologies/instant-client/linux-x86-64-downloads.html。</a><br>当前本地环境为<code>python 2.7</code>，选择了如下的包：<br>instantclient-basic-linux.x64-11.2.0.4.0.zip<br>instantclient-sdk-linux.x64-11.2.0.4.0.zip</p>
<a id="more"></a>

<h3 id="安装oracle-instantclient"><a href="#安装oracle-instantclient" class="headerlink" title="安装oracle instantclient"></a>安装oracle instantclient</h3><p>将上一步骤的zip包解压。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir -p ~/tools/oracle</span><br><span class="line">cp instantclient-basic-linux.x64-11.2.0.4.0.zip ~/tools/oracle</span><br><span class="line">cp instantclient-sdk-linux.x64-11.2.0.4.0.zip ~/tools/oracle</span><br><span class="line"><span class="built_in">cd</span> ~/tools/oracle</span><br><span class="line">unzip instantclient-sdk-linux.x64-11.2.0.4.0.zip</span><br><span class="line">unzip instantclient-basic-linux.x64-11.2.0.4.0.zip</span><br><span class="line"><span class="built_in">cd</span> instantclient_11_2</span><br><span class="line">cp -R sdk/* ./</span><br><span class="line">cp -R ./sdk/include/* .</span><br><span class="line">ln -s libclntsh.so.12.1 libclntsh.so</span><br><span class="line">ln -s libocci.so.12.1 libocci.so</span><br><span class="line"><span class="built_in">export</span> ORACLE_HOME=~/tools/oralce/instantclient_11_2/</span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=<span class="variable">$LD_LIBRARY_PATH</span>:<span class="variable">$ORACLE_HOME</span></span><br></pre></td></tr></table></figure>

<p>###编译安装cx_Oracle<br>先需要下载cx_Oracle的源码，从<a href="https://github.com/oracle/python-cx_Oracle" target="_blank" rel="noopener">github网站</a>,可以下载到。由于我使用的<code>python 2.7</code>根据介绍，使用<a href="https://github.com/oracle/python-cx_Oracle/archive/5.3.zip" target="_blank" rel="noopener">5.x的版本</a>。<br>下载后安装步骤如下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">unzip python-cx_Oracle-5.3.zip</span><br><span class="line"><span class="built_in">cd</span> python-cx_Oracle-5.3</span><br><span class="line">python setup.py build</span><br><span class="line">mkdir install</span><br><span class="line"><span class="built_in">export</span> PYTHONPATH=<span class="variable">$PYTHONPATH</span>:~/tools/oralce/python-cx_Oracle-5.3/install</span><br><span class="line">python setup.py install --prefix=~/tools/oralce/python-cx_Oracle-5.3/install</span><br><span class="line"><span class="comment">## 注意上个步骤会报错，执行下面的步骤继续</span></span><br><span class="line"><span class="built_in">export</span> PYTHONPATH=<span class="variable">$PYTHONPATH</span>:~/tools/oralce/python-cx_Oracle-5.3/installlib/python2.7/site-packages/</span><br><span class="line">python setup.py install --prefix=~/tools/oralce/python-cx_Oracle-5.3/install</span><br></pre></td></tr></table></figure>
<p>按照上面的步骤就可以安装成功了。</p>
<p>###cx_Oracle使用<br>因为当前不是在系统路径安装的，所以重新开一个窗口会导致<code>import cx_Oracle</code>失败，需要编写一个脚本来进行环境变量的设置，然后加入到<code>.bashrc</code>中也是可以的。<br>下面是设置环境变量的脚本(<code>envsetup.sh</code>):</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> ORACLE_HOME=~/tools/oralce/instantclient_11_2/</span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=<span class="variable">$LD_LIBRARY_PATH</span>:<span class="variable">$ORACLE_HOME</span></span><br><span class="line"><span class="built_in">export</span> PYTHONPATH=<span class="variable">$PYTHONPATH</span>:~/tools/oralce/python-cx_Oracle-5.3/installlib/python2.7/site-packages/</span><br></pre></td></tr></table></figure>
<p>上面的步骤执行完后，就可以在Python中导入<code>cx_Oracle</code>模块了。</p>
<p>###总结<br>其实该方法可以推广到其他模块的安装，当你需要在本地临时验证时。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol>
<li><a href="https://www.cnblogs.com/doctormo/p/12059738.html" target="_blank" rel="noopener">https://www.cnblogs.com/doctormo/p/12059738.html</a></li>
<li><a href="https://blog.csdn.net/yuan_lo/article/details/48289317" target="_blank" rel="noopener">https://blog.csdn.net/yuan_lo/article/details/48289317</a></li>
<li><a href="https://stackoverflow.com/questions/25885467/cx-oracle-pip-install-fails-oci-h-no-such-file-or-directory" target="_blank" rel="noopener">https://stackoverflow.com/questions/25885467/cx-oracle-pip-install-fails-oci-h-no-such-file-or-directory</a></li>
</ol>
]]></content>
      <tags>
        <tag>python oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>dexfile 文件格式</title>
    <url>/2020/07/24/dexfile/</url>
    <content><![CDATA[<p>Android APK中，最终java文件会被编译为classes.dex文件。如果要分析APK就得了解dex文件的格式。<br>dex文件的格式在AOSP源码的<code>dalvik/libdex/DexFile.h</code>有定义。</p>
]]></content>
  </entry>
  <entry>
    <title>Andorid SDK 下载</title>
    <url>/2020/07/29/downloadAndroidSDK/</url>
    <content><![CDATA[<h2 id="下载commandlinetools"><a href="#下载commandlinetools" class="headerlink" title="下载commandlinetools"></a>下载commandlinetools</h2><p>下载地址：<a href="https://developer.android.com/studio" target="_blank" rel="noopener">https://developer.android.com/studio</a> 点击进去可以查看<code>Command line tools only</code>小节</p>
<h2 id="解压安装commandlinetools"><a href="#解压安装commandlinetools" class="headerlink" title="解压安装commandlinetools"></a>解压安装commandlinetools</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cp commandlinetools-linux-6609375_latest.zip ~/</span><br><span class="line">mkdir -p ~/Android/platform-tools</span><br><span class="line">unzip  ~/Android/commandlinetools-linux-6609375_latest.zip -d ~/Android/platform-tools/</span><br><span class="line"><span class="built_in">export</span> ANDROID_HOME=~/Android</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>$:<span class="variable">$ANDROID_HOME</span>/cmdline-tools/tools/bin</span><br></pre></td></tr></table></figure>

<p>##安装android sdk<br>安装sdk请参考官方文档：<code>https://developer.android.com/studio/command-line/sdkmanager</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sdkmanager <span class="string">"platform-tools"</span> <span class="string">"platforms;android-28"</span></span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>Hexo+github博客搭建</title>
    <url>/2020/05/08/hello-world/</url>
    <content><![CDATA[<p>&emsp;&emsp;hexo是一个博客框架，可以将markdown文本编译成静态网页。github提供了github pages,这是一个静态网站托管服务。所以前者生成的静态网页可以托管在github pages上。通过在网上搜索，发现<a href="https://cuiqingcai.com/7625.html" target="_blank" rel="noopener">这篇文章</a>写的很详细，根据这篇文章部署了该<a href="https://wdxx.github.io/" target="_blank" rel="noopener">博客网站</a>。</p>
<a id="more"></a>

<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>&emsp;&emsp;搭建前需要先安装好Node.js，可以通过<a href="https://nodejs.org/zh-cn/download/" target="_blank" rel="noopener">这里</a>下载安装。然后就是安装hexo与github pages创建。需要注意的是在申请github作为github pages的仓库时，仓库名需要是{name}.github.io的命名方式。如果你还没有github账户的话赶紧去<a href="https://github.com/" target="_blank" rel="noopener">官网</a>申请一个吧。</p>
<h3 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h3><p>安装命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>

<h2 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h2><p>&emsp;&emsp;到目前为止，我们的准备工作已经完成了，我们拥有了hexo框架，github仓库。接下来需要做的就是使用hexo来初始化一个博客项目，hexo提供了一个命令行工具，用于快速创建项目、页面、编译、部署hexo博客。创建博客项目的命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir myblogsite</span><br><span class="line"><span class="built_in">cd</span> myblogsite</span><br><span class="line">hexo init &#123;name&#125; <span class="comment">## name就是你要创建的项目的名字，一般取签名说的github的用户名就可以了。</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这个步骤中hexo为我们的博客项目创建了{name}文件夹，这个文件夹下面还有node_modules、scaffolds、themes等文件夹，先不管这些文件夹有啥作用，继续后面的步骤。我{name}文件夹下面可以看到一个source/_post文件夹，这个下面可以存放markdown个是的文本文件，hexo可以将这个文件编译成静态的html,然后我们就可以用来部署了。将markdown格式的文件编译成html的命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> &#123;name&#125;</span><br><span class="line">hexo generate <span class="comment">## 也可以使用  hexo g 命令</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;执行上面的命令后可以发现在{name}/public下生成了许多文件，这就是转换过程重生成的文件。可以通过如下的命令在本地调试查看生成的效果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在上面的命令执行完成后，如果服务启动正常，那么会打印如下的log：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">INFO  Start processing</span><br><span class="line">INFO  Hexo is running at http://localhost:4000 . Press Ctrl+C to stop.</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;可以看到，访问的地址为”<a href="http://localhost:4000&quot;，在浏览器中打开就可以看到效果了。">http://localhost:4000&quot;，在浏览器中打开就可以看到效果了。</a></p>
<h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>&emsp;&emsp;从上面的步骤中已经生成了静态的页面，接下来只需要部署到github就可以了。在部署之前需要安装一个git的部署插件，安装命令如下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;接下来需要配置部署地址。打开项目文件夹下面的”_config.yml”文件，找到”Deployment”配置项，配置成如下格式:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repo: https://github.com/wdxx/wdxx.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;将type配置成git,repo配置成github项目地址，branch配置成github仓库分支。配置完地址之后执行如下部署命令:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo deploy</span><br></pre></td></tr></table></figure>
<p>部署过程会上传编译好的结果，log如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Counting objects: 58, <span class="keyword">done</span>.</span><br><span class="line">Delta compression using up to 4 threads.</span><br><span class="line">Compressing objects: 100% (52/52), <span class="keyword">done</span>.</span><br><span class="line">Writing objects: 100% (58/58), 358.87 KiB | 0 bytes/s, <span class="keyword">done</span>.</span><br><span class="line">Total 58 (delta 8), reused 0 (delta 0)</span><br><span class="line">remote: Resolving deltas: 100% (8/8), <span class="keyword">done</span>.</span><br><span class="line">To https://github.com/wdxx/wdxx.github.io.git</span><br><span class="line">   3cd02f7..13b140e  HEAD -&gt; master</span><br><span class="line">Branch master <span class="built_in">set</span> up to track remote branch master from https://github.com/wdxx/wdxx.github.io.git.</span><br><span class="line">INFO  Deploy <span class="keyword">done</span>: git</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;现在就可以打开<a href="https://wdxx.github.io/" target="_blank" rel="noopener">https://wdxx.github.io/</a>看看部署好后的效果了。</p>
<h2 id="修改主题"><a href="#修改主题" class="headerlink" title="修改主题"></a>修改主题</h2><p>&emsp;&emsp;hexo提供了各种各样的主题用于定义自己喜欢的样式，一般使用最流行的<a href="https://github.com/theme-next/hexo-theme-next/tree/v7.8.0" target="_blank" rel="noopener">next</a>主题，主题需要自己单独下载，存放在工程的themes目录下。下载next的命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/theme-next/hexo-theme-next.git themes/next</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;下载完主题后，需要在工程目录的”_config.yml”中将主题切换为next,在该文件中找到”Extensions”字段，配置成如下格式:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line">theme: next</span><br></pre></td></tr></table></figure>

<h2 id="重新部署"><a href="#重新部署" class="headerlink" title="重新部署"></a>重新部署</h2><p>&emsp;&emsp;在修改完配置，或者新发布文章后，需要重新编译然后部署，命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo generate</span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure>

<h2 id="配置站点信息"><a href="#配置站点信息" class="headerlink" title="配置站点信息"></a>配置站点信息</h2><p>&emsp;&emsp;可以在 _config.yml 中修改大部分的配置。这里我们主要修改site区域的配置。各参数说明如下:  </p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="right">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">title</td>
<td align="right">网站标题</td>
</tr>
<tr>
<td align="left">subtitle</td>
<td align="right">网站副标题</td>
</tr>
<tr>
<td align="left">description</td>
<td align="right">网站描述</td>
</tr>
<tr>
<td align="left">keywords</td>
<td align="right">网站的关键词。使用半角逗号 , 分隔多个关键词</td>
</tr>
<tr>
<td align="left">author</td>
<td align="right">您的名字</td>
</tr>
<tr>
<td align="left">language</td>
<td align="right">网站使用的语言。对于简体中文用户来说，使用不同的主题可能需要设置成不同的值，请参考你的主题的文档自行设置，常见的有 zh-Hans和 zh-CN。</td>
</tr>
<tr>
<td align="left">timezone</td>
<td align="right">网站时区。Hexo 默认使用您电脑的时区。请参考 时区列表 进行设置，如 America/New_York, Japan, 和 UTC 。一般的，对于中国大陆地区可以使用 Asia/Shanghai。</td>
</tr>
</tbody></table>
<p>我的博客具体配置如下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Site</span></span><br><span class="line">title: wdxxliu</span><br><span class="line">subtitle: 个人博客</span><br><span class="line">description: 一个关于嵌入式方向的个人博客</span><br><span class="line">keywords: <span class="string">"Python C/C++ Makefile Linux 编译 工具链"</span></span><br><span class="line">author: wdxx</span><br><span class="line">language: zh-CN</span><br><span class="line">timezone: Asia/Shanghai</span><br></pre></td></tr></table></figure>



]]></content>
  </entry>
  <entry>
    <title>如何在kernel中获取当前进程的信息</title>
    <url>/2020/08/18/kernel-get-process-info/</url>
    <content><![CDATA[<p>&emsp;&emsp;在kernel中有时候可能需要根据当前进行的某些信息进行逻辑处理，本文就是介绍如果在kernel中如果获取当前进程的信息。<br>&emsp;&emsp;在kernel中关于进程信息的一个重要的结构体就是task_struct，定义如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> &#123;</span></span><br><span class="line"><span class="comment">//这个是进程的运行时状态，-1代表不可运行，0代表可运行，&gt;0代表已停止。</span></span><br><span class="line"> <span class="keyword">volatile</span> <span class="keyword">long</span> state;</span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">flags是进程当前的状态标志，具体的如：</span></span><br><span class="line"><span class="comment">0x00000002表示进程正在被创建；</span></span><br><span class="line"><span class="comment">0x00000004表示进程正准备退出；</span></span><br><span class="line"><span class="comment">0x00000040 表示此进程被fork出，但是并没有执行exec；</span></span><br><span class="line"><span class="comment">0x00000400表示此进程由于其他进程发送相关信号而被杀死 。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">int</span> flags;</span><br><span class="line"><span class="comment">//表示此进程的运行优先级</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">int</span> rt_priority;</span><br><span class="line"><span class="comment">//这里出现了list_head结构体，详情请参考</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">tasks</span>;</span></span><br><span class="line"><span class="comment">//这里出现了mm_struct 结构体，该结构体记录了进程内存使用的相关情况，详情请参考</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span>;</span></span><br><span class="line"><span class="comment">/* 接下来是进程的一些状态参数*/</span></span><br><span class="line"> <span class="keyword">int</span> exit_state;</span><br><span class="line"> <span class="keyword">int</span> exit_code, exit_signal;</span><br><span class="line"><span class="comment">//这个是进程号</span></span><br><span class="line"> <span class="keyword">pid_t</span> pid;</span><br><span class="line"><span class="comment">//这个是进程组号</span></span><br><span class="line"> <span class="keyword">pid_t</span> tgid;</span><br><span class="line"><span class="comment">//real_parent是该进程的”亲生父亲“，不管其是否被“寄养”。</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">real_parent</span>;</span></span><br><span class="line"><span class="comment">//parent是该进程现在的父进程，有可能是”继父“</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">parent</span>;</span></span><br><span class="line"><span class="comment">//这里children指的是该进程孩子的链表，可以得到所有孩子的进程描述符，但是需使用list_for_each和list_entry，list_entry其实直接使用了container_of，详情请参考</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">children</span>;</span></span><br><span class="line"><span class="comment">//同理，sibling该进程兄弟的链表，也就是其父亲的所有孩子的链表。用法与children相似。</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">sibling</span>;</span></span><br><span class="line"><span class="comment">//这个是主线程的进程描述符，也许你会奇怪，为什么线程用进程描述符表示，因为linux并没有单独实现线程的相关结构体，只是用一个进程来代替线程，然后对其做一些特殊的处理。</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">group_leader</span>;</span></span><br><span class="line"><span class="comment">//这个是该进程所有线程的链表。</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">thread_group</span>;</span></span><br><span class="line"><span class="comment">//顾名思义，这个是该进程使用cpu时间的信息，utime是在用户态下执行的时间，stime是在内核态下执行的时间。</span></span><br><span class="line"> <span class="keyword">cputime_t</span> utime, stime;</span><br><span class="line"><span class="comment">//下面的是启动的时间，只是时间基准不一样。</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">start_time</span>;</span> </span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">real_start_time</span>;</span></span><br><span class="line"><span class="comment">//comm是保存该进程名字的字符数组，长度最长为15，因为TASK_COMM_LEN为16。</span></span><br><span class="line"> <span class="keyword">char</span> comm[TASK_COMM_LEN];</span><br><span class="line"><span class="comment">/* 文件系统信息计数*/</span></span><br><span class="line"> <span class="keyword">int</span> link_count, total_link_count;</span><br><span class="line"><span class="comment">/*该进程在特定CPU下的状态*/</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">thread_struct</span> <span class="title">thread</span>;</span></span><br><span class="line"><span class="comment">/* 文件系统相关信息结构体*/</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">fs_struct</span> *<span class="title">fs</span>;</span></span><br><span class="line"><span class="comment">/* 打开的文件相关信息结构体*/</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> *<span class="title">files</span>;</span></span><br><span class="line"> <span class="comment">/* 信号相关信息的句柄*/</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">signal_struct</span> *<span class="title">signal</span>;</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">sighand_struct</span> *<span class="title">sighand</span>;</span></span><br><span class="line"> <span class="comment">/*这些是松弛时间值，用来规定select()和poll()的超时时间，单位是纳秒nanoseconds */</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">long</span> timer_slack_ns;</span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">long</span> default_timer_slack_ns;</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>如果需要获取其中的某些信息，获取对应的<code>task_struct</code>中的字段就可以了。在实际应用中，经常需要处理的就是获取当前进程的信息，这时候可以借助内核宏<code>current</code>，通过该宏可以获取到当前进程的<code>task_struct</code>。下面是针对<code>task_struct</code>的应用示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/sched.h&gt; //task_pid_nr</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* This function is called when the module is loaded. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">simple_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">       printk(KERN_INFO <span class="string">"Loading Module\n"</span>);</span><br><span class="line">       printk(<span class="string">"The process id is %d\n"</span>, (<span class="keyword">int</span>) task_pid_nr(current));</span><br><span class="line">       printk(<span class="string">"The process vid is %d\n"</span>, (<span class="keyword">int</span>) task_pid_vnr(current));</span><br><span class="line">       printk(<span class="string">"The process name is %s\n"</span>, current-&gt;comm);</span><br><span class="line">       printk(<span class="string">"The process tty is %d\n"</span>, current-&gt;signal-&gt;tty);</span><br><span class="line">       printk(<span class="string">"The process group is %d\n"</span>, (<span class="keyword">int</span>) task_tgid_nr(current));</span><br><span class="line">       printk(<span class="string">"\n\n"</span>);</span><br><span class="line">   <span class="comment">//return -1; //debug mode of working</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This function is called when the module is removed. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">simple_exit</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">"Removing Module\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Macros for registering module entry and exit points. */</span></span><br><span class="line">module_init( simple_init );</span><br><span class="line">module_exit( simple_exit );</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</span><br><span class="line">MODULE_DESCRIPTION(<span class="string">"Simple Module"</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">"SGG"</span>);</span><br></pre></td></tr></table></figure>
<p>在直接读取这些字段的时候可能引起竞争，所以可以使用<code>get_task_comm()</code>等函数来进行读取。<code>get_task_comm()</code>函数的定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> get_task_comm(buf, tsk) (&#123;            \</span></span><br><span class="line">   BUILD_BUG_ON(<span class="keyword">sizeof</span>(buf) != TASK_COMM_LEN); \</span><br><span class="line">   __get_task_comm(buf, <span class="keyword">sizeof</span>(buf), tsk);     \</span><br><span class="line"> &#125;)</span><br><span class="line"></span><br><span class="line"> <span class="keyword">char</span> *__get_task_comm(<span class="keyword">char</span> *buf, <span class="keyword">size_t</span> buf_size, struct task_struct *tsk)</span><br><span class="line"> &#123;</span><br><span class="line">   task_lock(tsk);</span><br><span class="line">   <span class="built_in">strncpy</span>(buf, tsk-&gt;comm, buf_size);</span><br><span class="line">   task_unlock(tsk);</span><br><span class="line">   <span class="keyword">return</span> buf;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>kernel pid</tag>
      </tags>
  </entry>
  <entry>
    <title>linux_filesystem</title>
    <url>/2020/08/19/linux-filesystem/</url>
    <content><![CDATA[<p>Linux中常见的文件系统是ext4文件系统，那文件系统的基本组成是什么样的呢？Linux操作系统中，文件除了实际的数据之外还有诸如权限、文件属性类的数据。文件系统通常会将实际的数据存放在<code>block</code>中，而权限及文件属性数据存放在<code>inode</code>中。</p>
<h2 id="inode-和-block-概述"><a href="#inode-和-block-概述" class="headerlink" title="inode 和 block 概述"></a>inode 和 block 概述</h2><p>文件是存储在硬盘上的，硬盘的最小存储单位叫做扇区<code>sector</code>，每个扇区存储<code>512字节</code>。操作系统读取硬盘的时候，不会一个个扇区地读取，这样效率太低，而是一次性连续读取多个扇区，即一次性读取一个块<code>block</code>。这种由多个扇区组成的块，是文件存取的最小单位。块的大小，最常见的是<code>4KB</code>，即连续八个sector组成一个<code>block</code>。</p>
<p>文件数据存储在块中，那么还必须找到一个地方存储文件的元信息，比如文件的创建者、文件的创建日期、文件的大小等等。这种存储文件元信息的区域就叫做<code>inode</code>，中文译名为<code>索引节点</code>，也叫<code>i节点</code>。因此，一个文件必须占用一个<code>inode</code>，但至少占用一个<code>block</code>。</p>
<ul>
<li>元信息：inode</li>
<li>数据: block</li>
</ul>
<h2 id="inode内容"><a href="#inode内容" class="headerlink" title="inode内容"></a>inode内容</h2><p><code>inode</code>包含很多的文件元信息，但不包含文件名，例如：字节数、属主<code>UserID</code>、属组<code>GroupID</code>、读写执行权限、时间戳等。</p>
<p>而文件名存放在目录当中，但Linux系统内部不使用文件名，而是使用<code>inode号码</code>识别文件。对于系统来说文件名只是<code>inode号码</code>便于识别的别称。</p>
<h2 id="inode号码"><a href="#inode号码" class="headerlink" title="inode号码"></a>inode号码</h2><p>可以通过<code>stat</code>命令或者<code>ls -i</code>命令查看文件或者目录的<code>inode号码</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">stat</span> readme.txt</span><br><span class="line">  文件：<span class="string">"readme.txt"</span></span><br><span class="line">  大小：6          块：8          IO 块：4096   普通文件</span><br><span class="line">设备：fc02h/64514d Inode：88617255    硬链接：1</span><br><span class="line">权限：(0664/-rw-rw-r--)  Uid：( 5002/xxx)   Gid：( 1003/xxx)</span><br><span class="line">最近访问：2020-08-19 10:19:33.431665414 +0800</span><br><span class="line">最近更改：2020-08-19 10:19:33.431665414 +0800</span><br><span class="line">最近改动：2020-08-19 10:19:33.431665414 +0800</span><br><span class="line">创建时间：-</span><br><span class="line"></span><br><span class="line">ls -i readme.txt</span><br><span class="line">88617255 readme.txt</span><br></pre></td></tr></table></figure>
<p>表面上，用户通过文件名打开文件，实际上，系统内部将这个过程分为三步：</p>
<ol>
<li>系统找到这个文件名对应的<code>inode号码</code>；</li>
<li>通过<code>inode号码</code>，获取<code>inode信息</code>；</li>
<li>根据<code>inode信息</code>，找到文件数据所在的<code>block</code>，并读出数据。<br>其实系统还要根据<code>inode信息</code>，看用户是否具有<code>访问权限</code>，有就指向对应的数据<code>block</code>，没有就返回权限拒绝。</li>
</ol>
]]></content>
      <tags>
        <tag>Linux filesystem 文件系统</tag>
      </tags>
  </entry>
  <entry>
    <title>将modules和exponent转换为公钥</title>
    <url>/2020/05/22/modulus-and-exponent-to-publicKey/</url>
    <content><![CDATA[<p>&emsp;&emsp;在使用加解密时，有时候我们拿到的是公钥中的modulus和exponent字段，当需要通过使用openssl工具进行验签或者加密的时候，就需要将这些信息转换成公钥了。本文介绍如何将modules和exponent转换为公钥。</p>
<a id="more"></a>
<h2 id="公钥文件分析"><a href="#公钥文件分析" class="headerlink" title="公钥文件分析"></a>公钥文件分析</h2><p>使用如下命令dump出公钥的信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ openssl rsa -pubin -in  pub.pem -noout -text</span><br><span class="line">Public-Key: (2048 bit)</span><br><span class="line">Modulus:</span><br><span class="line">    00:a0:10:a8:32:0b:cb:75:db:7d:8e:ba:a5:df:56:</span><br><span class="line">    b2:fb:9c:e9:34:b3:ae:7b:0b:07:a6:13:40:28:13:</span><br><span class="line">    be:78:5f:69:09:c1:bb:5e:52:62:aa:a3:f5:38:5d:</span><br><span class="line">    70:c2:3c:95:05:71:e8:87:57:10:a0:5d:7b:8a:f7:</span><br><span class="line">    dd:a3:e4:85:f5:e1:e7:ba:e2:34:4c:18:9f:46:55:</span><br><span class="line">    15:49:b5:48:92:22:ed:84:24:17:86:bf:69:10:55:</span><br><span class="line">    42:76:4b:55:bf:d3:ce:a4:2a:bd:5e:a2:e5:29:84:</span><br><span class="line">    4f:77:08:3a:22:04:5c:00:de:8b:9b:ee:7f:68:b0:</span><br><span class="line">    b0:9b:e8:bb:b1:99:e6:8a:cf:9e:b9:85:d2:86:d3:</span><br><span class="line">    5e:c2:a4:56:8d:f8:87:1d:6c:b3:73:83:3e:7b:bc:</span><br><span class="line">    5d:c6:e2:63:fd:e1:4d:18:df:53:0f:4e:13:6f:fd:</span><br><span class="line">    a6:b7:8c:e9:26:a3:4e:2b:fd:61:3d:d1:b5:f4:2f:</span><br><span class="line">    ad:55:12:57:2a:20:ed:30:e7:64:3c:87:26:47:ef:</span><br><span class="line">    97:48:30:df:44:f2:ed:c6:54:ed:5e:4f:dd:d9:3d:</span><br><span class="line">    64:51:02:f9:7b:56:77:44:63:b0:95:1a:5e:83:4b:</span><br><span class="line">    82:ce:59:f2:9e:e1:fc:16:1c:fc:f6:9c:55:37:73:</span><br><span class="line">    ae:6a:e9:76:0c:9e:3a:b1:fc:cf:76:20:6b:17:d4:</span><br><span class="line">    87:c3</span><br><span class="line">Exponent: 65537 (0x10001)</span><br></pre></td></tr></table></figure>
<p>从上面的信息可以看到<code>exponent</code>的值为<code>65537</code>。上面的信息中发现我们的public key的长度是2048位的，但是modulus有257个字节，合计2056（257*8）位,经过验证发现<code>modulus</code>中的第一位<code>00</code>是不需要的。后面根据<a href="https://stackoverflow.com/questions/5403808/private-key-length-bytes" target="_blank" rel="noopener">网上资料</a>发现rsa格式的密钥，它的密钥长度跟<code>modulus</code>的长度是一致的，第一位<code>00</code>不影响<code>modulus</code>的大小，也就不会影响公钥的长度了。  </p>
<h3 id="导出hex格式的modulus"><a href="#导出hex格式的modulus" class="headerlink" title="导出hex格式的modulus"></a>导出hex格式的modulus</h3><p>通过openssl asn1parse可以查看密钥的格式,关于pem格式的密钥的介绍请看<a href="https://www.cnblogs.com/adylee/p/9366518.html" target="_blank" rel="noopener">这里</a>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ openssl asn1parse -in pub.pem  -i</span><br><span class="line">    0:d&#x3D;0  hl&#x3D;4 l&#x3D; 290 cons: SEQUENCE          </span><br><span class="line">    4:d&#x3D;1  hl&#x3D;2 l&#x3D;  13 cons:  SEQUENCE          </span><br><span class="line">    6:d&#x3D;2  hl&#x3D;2 l&#x3D;   9 prim:   OBJECT            :rsaEncryption</span><br><span class="line">   17:d&#x3D;2  hl&#x3D;2 l&#x3D;   0 prim:   NULL              </span><br><span class="line">   19:d&#x3D;1  hl&#x3D;4 l&#x3D; 271 prim:  BIT STRING</span><br></pre></td></tr></table></figure>
<p>其中<code>BIT STRING</code>就是modulus，可以看到它的<code>offset</code>为19,通过如下命令导出hex格式的modulus：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ openssl asn1parse -in pub.pem  -i -dump -strparse 19</span><br><span class="line">    0:d&#x3D;0  hl&#x3D;4 l&#x3D; 266 cons: SEQUENCE          </span><br><span class="line">    4:d&#x3D;1  hl&#x3D;4 l&#x3D; 257 prim: INTEGER           :A010A8320BCB75DB7D8EBAA5DF56B2FB9CE934B3AE7B0B07A613402813BE785F6909C1BB5E5262AAA3F5385D70C23C950571E8875710A05D7B8AF7DDA3E485F5E1E7BAE2344C189F46551549B5489222ED84241786BF69105542764B55BFD3CEA42ABD5EA2E529844F77083A22045C00DE8B9BEE7F68B0B09BE8BBB199E68ACF9EB985D286D35EC2A4568DF8871D6CB373833E7BBC5DC6E263FDE14D18DF530F4E136FFDA6B78CE926A34E2BFD613DD1B5F42FAD5512572A20ED30E7643C872647EF974830DF44F2EDC654ED5E4FDDD93D645102F97B56774463B0951A5E834B82CE59F29EE1FC161CFCF69C553773AE6AE9760C9E3AB1FCCF76206B17D487C3</span><br><span class="line">  265:d&#x3D;1  hl&#x3D;2 l&#x3D;   3 prim: INTEGER           :010001</span><br></pre></td></tr></table></figure>
<p>可以看到其中的modulus跟上小节中使用<code>openssl rsa</code>命令导出的一样，但是去掉了开头的<code>00</code>。</p>
<h2 id="提取公钥"><a href="#提取公钥" class="headerlink" title="提取公钥"></a>提取公钥</h2><p>这里对公钥的提取需要使用到Python的<a href="https://github.com/dlitz/pycrypto" target="_blank" rel="noopener">pycrypto</a>库。代码如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.PublicKey.RSA <span class="keyword">import</span> construct</span><br><span class="line">e = long(<span class="number">65537</span>) <span class="comment">## Exponent</span></span><br><span class="line">n = int(<span class="string">'A010A8320BCB75DB7D8EBAA5DF56B2FB9CE934B3AE7B0B07A613402813BE785F6909C1BB5E5262AAA3F5385D70C23C950571E8875710A05D7B8AF7DDA3E485F5E1E7BAE2344C189F46551549B5489222ED84241786BF69105542764B55BFD3CEA42ABD5EA2E529844F77083A22045C00DE8B9BEE7F68B0B09BE8BBB199E68ACF9EB985D286D35EC2A4568DF8871D6CB373833E7BBC5DC6E263FDE14D18DF530F4E136FFDA6B78CE926A34E2BFD613DD1B5F42FAD5512572A20ED30E7643C872647EF974830DF44F2EDC654ED5E4FDDD93D645102F97B56774463B0951A5E834B82CE59F29EE1FC161CFCF69C553773AE6AE9760C9E3AB1FCCF76206B17D487C3'</span>, <span class="number">16</span>) <span class="comment">## modulus</span></span><br><span class="line">pubkey = construct((n, e))</span><br><span class="line">strkey = pubkey.exportKey()</span><br><span class="line"><span class="keyword">print</span> strkey</span><br></pre></td></tr></table></figure>
<p>需要注意的是e、n都需要是long类型的，不然会报错，最终获取到如下的key。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-----BEGIN PUBLIC KEY-----</span><br><span class="line">MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAoBCoMgvLddt9jrql31ay</span><br><span class="line">+5zpNLOuewsHphNAKBO+eF9pCcG7XlJiqqP1OF1wwjyVBXHoh1cQoF17ivfdo+SF</span><br><span class="line">9eHnuuI0TBifRlUVSbVIkiLthCQXhr9pEFVCdktVv9POpCq9XqLlKYRPdwg6IgRc</span><br><span class="line">AN6Lm+5&#x2F;aLCwm+i7sZnmis+euYXShtNewqRWjfiHHWyzc4M+e7xdxuJj&#x2F;eFNGN9T</span><br><span class="line">D04Tb&#x2F;2mt4zpJqNOK&#x2F;1hPdG19C+tVRJXKiDtMOdkPIcmR++XSDDfRPLtxlTtXk&#x2F;d</span><br><span class="line">2T1kUQL5e1Z3RGOwlRpeg0uCzlnynuH8Fhz89pxVN3Ouaul2DJ46sfzPdiBrF9SH</span><br><span class="line">wwIDAQAB</span><br><span class="line">-----END PUBLIC KEY-----</span><br></pre></td></tr></table></figure>

<h3 id="关于Crypto-PublicKey-RSA-construct"><a href="#关于Crypto-PublicKey-RSA-construct" class="headerlink" title="关于Crypto.PublicKey.RSA.construct"></a>关于Crypto.PublicKey.RSA.construct</h3><p>下面是Crypto.PublicKey.RSA.construct方法的介绍:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;&quot;&quot;Construct an RSA key from a tuple of valid RSA components.</span><br><span class="line">The modulus **n** must be the product of two primes.</span><br><span class="line">The public exponent **e** must be odd and larger than 1.</span><br><span class="line">In case of a private key, the following equations must apply:</span><br><span class="line">- e !&#x3D; 1</span><br><span class="line">- p*q &#x3D; n</span><br><span class="line">- e*d &#x3D; 1 mod (p-1)(q-1)</span><br><span class="line">- p*u &#x3D; 1 mod q</span><br><span class="line">:Parameters:</span><br><span class="line"> tup : tuple</span><br><span class="line">            A tuple of long integers, with at least 2 and no</span><br><span class="line">            more than 6 items. The items come in the following order:</span><br><span class="line">            1. RSA modulus (n).</span><br><span class="line">            2. Public exponent (e).</span><br><span class="line">            3. Private exponent (d). Only required if the key is private.</span><br><span class="line">            4. First factor of n (p). Optional.</span><br><span class="line">            5. Second factor of n (q). Optional.</span><br><span class="line">            6. CRT coefficient, (1&#x2F;p) mod q (u). Optional.</span><br><span class="line"></span><br><span class="line">:Return: An RSA key object (&#96;_RSAobj&#96;).</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>
<p>想要了解这堆说明，需要先了解下<a href="https://zhuanlan.zhihu.com/p/44185847" target="_blank" rel="noopener"><code>RSA</code>算法的原理</a>。根据这篇文章我们可以知道如下几点：<br>1、 模数n = p<em>q,其中q与q互质<br>2、 e是一个随机数，它不等于1，并且与(q-1)</em>(p-1)互质。（算法上m = (q-1)<em>(p-1)）。<br>3、 d是一个整数，(e</em>d)%m = 1, 这里得到的d是私钥的一部分。<br>公钥：(n, e)<br>私钥：(n, d)</p>
<h4 id="加密过程"><a href="#加密过程" class="headerlink" title="加密过程"></a>加密过程</h4><p>假设明文为a，那么密文b = a^e % n，可以看到我们用到了<code>(n, e)</code>，所以加密的时候是使用公钥进行加密的。其中需要注意的是，要想使用公钥（n，e) 加密，要求被加密的数字必须小于n。</p>
<h4 id="解密过程"><a href="#解密过程" class="headerlink" title="解密过程"></a>解密过程</h4><p>解密的时候用到私钥<code>(n, d)</code>，假设接收到的密文b,那么想要得到明文a,则需要通过如下计算：<br>a = b^d %n。</p>
<h3 id="关于验证过程中的注意事项"><a href="#关于验证过程中的注意事项" class="headerlink" title="关于验证过程中的注意事项"></a>关于验证过程中的注意事项</h3><p>验证的时候保证明文的一致性，如明文存在文件中，由于windows 、linux文件格式不一样，可能看上去字符串一样，但是文件的hash是不一样的。</p>
]]></content>
      <tags>
        <tag>加解密 openssl</tag>
      </tags>
  </entry>
  <entry>
    <title>linux nfs 挂载</title>
    <url>/2020/09/03/linux-nfs/</url>
    <content><![CDATA[<p>在Linux服务器上使用nfs挂载需要先安装nfs server。下面是Ubuntu上安装nfs server的命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install nfs-kernel-server</span><br><span class="line"><span class="comment">## nfs 配置目录在/etc/exports</span></span><br></pre></td></tr></table></figure>
<p>客户端需要安装<code>nfs-common</code>,安装方法如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install nfs-common</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="nfs-server配置"><a href="#nfs-server配置" class="headerlink" title="nfs server配置"></a>nfs server配置</h3><p>nfs server的配置文件在<code>/etc/exports</code>文件中，需要有<code>root</code>权限才能编辑。例如<code>/work/nfs_share 192.168.2.55(rw,sync,no_subtree_check)</code>表示允许192.168.2.55使用nfs挂载当前服务器的<code>/work/nfs_share</code>目录。下面列举下nfs配置的各个参数：</p>
<ul>
<li>ro 该主机对该共享目录有只读权限</li>
<li>rw 该主机对该共享目录有读写权限</li>
<li>root_squash 客户机用root用户访问该共享文件夹时，将root用户映射成匿名用户</li>
<li>no_root_squash 客户机用root访问该共享文件夹时，不映射root用户</li>
<li>all_squash 客户机上的任何用户访问该共享目录时都映射成匿名用户</li>
<li>anonuid 将客户机上的用户映射成指定的本地用户ID的用户</li>
<li>anongid 将客户机上的用户映射成属于指定的本地用户组ID</li>
<li>sync 资料同步写入到内存与硬盘中</li>
<li>async 资料会先暂存于内存中，而非直接写入硬盘</li>
<li>insecure 允许从这台机器过来的非授权访问 </li>
<li>subtree_check 如果共享/usr/bin之类的子目录时，强制NFS检查父目录的权限（默认）</li>
<li>no_subtree_check 和上面相对，不检查父目录权限</li>
<li>wdelay 如果多个用户要写入NFS目录，则归组写入（默认）</li>
<li>no_wdelay 如果多个用户要写入NFS目录，则立即写入，当使用async时，无需此设置。</li>
<li>hide 在NFS共享目录中不共享其子目录</li>
<li>no_hide 共享NFS目录的子目录</li>
<li>secure NFS通过1024以下的安全TCP/IP端口发送</li>
<li>insecure NFS通过1024以上的端口发送<br>例子：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F; user01(rw) user02(rw,no_root_squash) 表示共享服务器上的根目录(&#x2F;)只有user01和user02两台主机可以访问，且有读写权限；user01主机用root用户身份访问时，将客户机的root用户映射成服务器上的匿名用户(root_squash,该参数为缺省参数)，相当于在服务器使用nobody用户访问目录；user02主机用root用户身份访问该共享目录时，不映射root用户(no_root_squash),即相当于在服务器上用root身份访问该目录</span><br><span class="line"></span><br><span class="line">　　&#x2F;root&#x2F;share&#x2F; 192.168.1.2(rw,insecure,sync,all_squash) 表示共享服务器上的&#x2F;root&#x2F;share&#x2F;目录只有192.168.1.2主机可以访问，且有读写权限；此主机用任何身份访问时，将客户机的用户都映射成服务器上的匿名用户(all_squash),相当于在服务器上用nobody用户访问该目录（若客户机要在该共享目录上保存文件（即写操作），则服务器上的nobody用户对该目录必须有写的权限）</span><br><span class="line"></span><br><span class="line">　　&#x2F;home&#x2F;ylw&#x2F; .test.com (rw,insecure,sync,all_squash) 表示共享&#x2F;home&#x2F;ylw&#x2F;目录，.test.com域中所有的主机都可以访问该目录，且有读写权限</span><br><span class="line"></span><br><span class="line">　　&#x2F;home&#x2F;share&#x2F; .test.com (ro,sync,all_squash,anonuid&#x3D;zh3,anongid&#x3D;wa4) 表示共享目录&#x2F;home&#x2F;share&#x2F;，*.test.com域中的所有主机都可以访问，但只有只读的权限，所有用户都映射成服务器上的uid为zh3、gid为wa4的用户</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/qq_36357820/article/details/78488077" target="_blank" rel="noopener">https://blog.csdn.net/qq_36357820/article/details/78488077</a></p>
]]></content>
  </entry>
  <entry>
    <title>oracle</title>
    <url>/2020/11/20/oracle/</url>
    <content><![CDATA[<p>Oracle数据库跟MySql数据库要复杂一些，有数据库、数据库实例等概念。</p>
<h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p>Oracle中的数据库指的是物理上的数据库文件或者磁盘中的数据，用户需要通过数据库实例来操作数据库。</p>
<h3 id="数据库实例"><a href="#数据库实例" class="headerlink" title="数据库实例"></a>数据库实例</h3><p>Oracle 实例是客户端应用程序(用户)和数据库之间的接口。也就是说数据库实例就是一个Oracle数据库服务器中某个后台进程，用户通过这个进程来访问对应的数据库。所以在Oracle链接的时候，是需要指定数据库实例服务名的。</p>
<a id="more"></a>

<h3 id="第一次登录"><a href="#第一次登录" class="headerlink" title="第一次登录"></a>第一次登录</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sqlplus /nolog</span><br><span class="line">connect / as sysdba</span><br><span class="line">select username,account_status from dba_users;</span><br><span class="line"><span class="comment">### 第一次登录，为sys、system用户设置初始密码</span></span><br><span class="line">alter user sys identified by 123456;</span><br><span class="line">alter user system identified by 123456;</span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line"><span class="comment">### sys 用户登录</span></span><br><span class="line">sys as sysdba</span><br><span class="line"><span class="comment">### 创建WORK用户，注意需要以C##开头</span></span><br><span class="line">CREATE USER C<span class="comment">##WORK IDENTIFIED BY 123456;</span></span><br></pre></td></tr></table></figure>

<h3 id="监听器无法启动"><a href="#监听器无法启动" class="headerlink" title="监听器无法启动"></a>监听器无法启动</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lsnrctl start LISTENER</span><br><span class="line">Starting tnslsnr:</span><br><span class="line"></span><br><span class="line">TNS-12557:TNS:protocol adapter not loadable</span><br><span class="line">TNS-12560:TNS:protocol adapter error</span><br><span class="line">TNS-00527:Protocol Adapter not loadable</span><br></pre></td></tr></table></figure>

<p>listener.ora</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># listener.ora Network Configuration File: D:\WINDOWS.X64_193000_db_home\NETWORK\ADMIN\listener.ora</span><br><span class="line"># Generated by Oracle configuration tools.</span><br><span class="line"></span><br><span class="line">SID_LIST_LISTENER &#x3D;</span><br><span class="line">  (SID_LIST &#x3D;</span><br><span class="line">    (SID_DESC &#x3D;</span><br><span class="line">      (SID_NAME &#x3D; CLRExtProc)</span><br><span class="line">      (ORACLE_HOME &#x3D; D:\WINDOWS.X64_193000_db_home)</span><br><span class="line">      (PROGRAM &#x3D; extproc)</span><br><span class="line">      (ENVS &#x3D; &quot;EXTPROC_DLLS&#x3D;ONLY:D:\WINDOWS.X64_193000_db_home\bin\oraclr19.dll&quot;)</span><br><span class="line">    )</span><br><span class="line">    (SID_DESC &#x3D;</span><br><span class="line">      (SID_NAME &#x3D; ORCL)</span><br><span class="line">      (ORACLE_HOME &#x3D; D:\WINDOWS.X64_193000_db_home)</span><br><span class="line">      (SID_NAME &#x3D; ORCL)</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">LISTENER &#x3D;</span><br><span class="line">  (DESCRIPTION_LIST &#x3D;</span><br><span class="line">    (DESCRIPTION &#x3D;</span><br><span class="line">      (ADDRESS &#x3D; (PROTOCOL &#x3D; TCP)(HOST &#x3D; 127.0.0.1)(PORT &#x3D; 1521))</span><br><span class="line">      (ADDRESS &#x3D; (PROTOCOL &#x3D; IPC)(KEY &#x3D; EXTPROC1521))</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">ADR_BASE_LISTENER &#x3D; D:\WINDOWS.X64_193000_db_home\log</span><br></pre></td></tr></table></figure>

<p>tnsnames.ora</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># tnsnames.ora Network Configuration File: D:\WINDOWS.X64_193000_db_home\NETWORK\ADMIN\tnsnames.ora</span><br><span class="line"># Generated by Oracle configuration tools.</span><br><span class="line"></span><br><span class="line">ORACLR_CONNECTION_DATA &#x3D;</span><br><span class="line">  (DESCRIPTION &#x3D;</span><br><span class="line">    (ADDRESS_LIST &#x3D;</span><br><span class="line">      (ADDRESS &#x3D; (PROTOCOL &#x3D; IPC)(Key &#x3D; EXTPROC))</span><br><span class="line">    )</span><br><span class="line">    (CONNECT_DATA &#x3D;</span><br><span class="line">      (SID &#x3D; CLRExtProc)</span><br><span class="line">      (PRESENTATION &#x3D; RO)</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">ORCL &#x3D;</span><br><span class="line">  (DESCRIPTION &#x3D;</span><br><span class="line">    (ADDRESS_LIST &#x3D;</span><br><span class="line">      (ADDRESS &#x3D; (PROTOCOL &#x3D; TCP)(HOST &#x3D; 127.0.0.1)(PORT &#x3D; 1521))</span><br><span class="line">    )</span><br><span class="line">    (CONNECT_DATA &#x3D;</span><br><span class="line">      (SERVICE_NAME &#x3D; ORCL)</span><br><span class="line">    )</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>

<h3 id="oracle-windows环境"><a href="#oracle-windows环境" class="headerlink" title="oracle windows环境"></a>oracle windows环境</h3><p>如果使用vs在windows环境下进行开发，需要安装ODTwithODAC。下载地址如下：<br><a href="https://download.oracle.com/otn/other/ole-oo4o/ODTwithODAC122011.zip?AuthParam=1604376209_ac2af019fab4ad7c6eb8360fec98cd0b" target="_blank" rel="noopener">https://download.oracle.com/otn/other/ole-oo4o/ODTwithODAC122011.zip?AuthParam=1604376209_ac2af019fab4ad7c6eb8360fec98cd0b</a></p>
<h2 id="windows编程"><a href="#windows编程" class="headerlink" title="windows编程"></a>windows编程</h2><h3 id="Windows-VS-ADO"><a href="#Windows-VS-ADO" class="headerlink" title="Windows VS ADO"></a>Windows VS ADO</h3><p>关于ADO的介绍参考：<a href="https://blog.csdn.net/i_likechard/article/details/81386694" target="_blank" rel="noopener">https://blog.csdn.net/i_likechard/article/details/81386694</a></p>
<p><a href="https://blog.csdn.net/luke2834/article/details/47778639" target="_blank" rel="noopener">https://blog.csdn.net/luke2834/article/details/47778639</a></p>
<p><a href="https://www.cnblogs.com/TenosDoIt/archive/2013/04/15/3022136.html" target="_blank" rel="noopener">https://www.cnblogs.com/TenosDoIt/archive/2013/04/15/3022136.html</a></p>
<p><a href="https://blog.csdn.net/lbcab/article/details/51329207" target="_blank" rel="noopener">https://blog.csdn.net/lbcab/article/details/51329207</a></p>
<p><a href="https://blog.csdn.net/shen_jz2012/article/details/51759858" target="_blank" rel="noopener">https://blog.csdn.net/shen_jz2012/article/details/51759858</a></p>
<h3 id="Microsoft-官方示例"><a href="#Microsoft-官方示例" class="headerlink" title="Microsoft 官方示例"></a>Microsoft 官方示例</h3><p><a href="https://docs.microsoft.com/zh-cn/office/client-developer/access/desktop-database-reference/ado-code-examples-in-microsoft-visual-c" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/office/client-developer/access/desktop-database-reference/ado-code-examples-in-microsoft-visual-c</a></p>
<h3 id="SOCI使用"><a href="#SOCI使用" class="headerlink" title="SOCI使用"></a>SOCI使用</h3><p><a href="https://www.jianshu.com/p/66ac4e90c602" target="_blank" rel="noopener">https://www.jianshu.com/p/66ac4e90c602</a></p>
]]></content>
  </entry>
  <entry>
    <title>openssl初探</title>
    <url>/2020/05/21/openssl-first/</url>
    <content><![CDATA[<h2 id="非对称加密算法概述"><a href="#非对称加密算法概述" class="headerlink" title="非对称加密算法概述"></a>非对称加密算法概述</h2><p>&emsp;&emsp;非对称加密算法也称公开密钥算法，其解决了对称加密算法密钥分配的问题，非对称加密算法基本特点如下：<br>1、加密密钥和解密密钥不同<br>2、密钥对中的一个密钥可以公开<br>3、根据公开密钥很难推算出私人密钥<br>&emsp;&emsp;根据非对称加密算法的特点，可用户数字签名、密钥交换、数据加密。但是由于非对称加密算法较对称加密算法加密速度慢很多，故最常用的用途是数字签名和密钥交换。<br>&emsp;&emsp;目前常用的非对称加密算法有RSA, DH和DSA三种，但并非都可以用于密钥交换和数字签名。而是RSA可用于数字签名和密钥交换，DH算法可用于密钥交换，而DSA算法专门用户数字签名。<br>&emsp;&emsp;openssl支持以上三种算法，并为三种算法提供了丰富的指令集，目前使用最多的算法是rsa加密算法，本文介绍OpenSSL在rsa加密算法上的使用。</p>
<a id="more"></a>

<h2 id="openssl-rsa算法相关指令与用法"><a href="#openssl-rsa算法相关指令与用法" class="headerlink" title="openssl rsa算法相关指令与用法"></a>openssl rsa算法相关指令与用法</h2><p>&emsp;&emsp;RSA虽然可以数字签名、密钥交换和数据加密，但是RSA加密数据速度慢，通常不使用RSA加密数据。对于在实际应用中是使用RSA算法进行签名还是进行加密，可以通过公钥与私钥的使用进行区别：<br>&emsp;&emsp;公钥加密：用途是密钥交换，用户A使用用户B的公钥将少量数据加密发送给B，B用自己的私钥解密数据。<br>&emsp;&emsp;私钥签名：用途是数字签名，用户A使用自己的私钥将数据的摘要信息加密一并发送给B，B用A的公钥解密摘要信息并验证。</p>
<h3 id="openssl-genrsa命令介绍"><a href="#openssl-genrsa命令介绍" class="headerlink" title="openssl genrsa命令介绍"></a>openssl genrsa命令介绍</h3><p>openssl genras 命令用于生成秘钥对，其用法如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xxx@cmos:~$ openssl genrsa -</span><br><span class="line">usage: genrsa [args] [numbits]                                                     //密钥位数，建议1024及以上</span><br><span class="line"> -des            encrypt the generated key with DES <span class="keyword">in</span> cbc mode                    //生成的密钥使用des方式进行加密</span><br><span class="line"> -des3           encrypt the generated key with DES <span class="keyword">in</span> ede cbc mode (168 bit key)  //生成的密钥使用des3方式进行加密</span><br><span class="line"> -seed</span><br><span class="line">                 encrypt PEM output with cbc seed                                  //生成的密钥还是要seed方式进行</span><br><span class="line"> -aes128, -aes192, -aes256</span><br><span class="line">                 encrypt PEM output with cbc aes                                   //生成的密钥使用aes方式进行加密</span><br><span class="line"> -camellia128, -camellia192, –camellia256 </span><br><span class="line">                 encrypt PEM output with cbc camellia                              //生成的密钥使用camellia方式进行加密</span><br><span class="line"> -out file       output the key to <span class="string">'file                                           //生成的密钥文件，可从中提取公钥</span></span><br><span class="line"><span class="string"> -passout arg    output file pass phrase source                                    //指定密钥文件的加密口令，可从文件、环境变量、终端等输入</span></span><br><span class="line"><span class="string"> -f4             use F4 (0x10001) for the E value                                  //选择指数e的值，默认指定该项，e值为65537 -3              use 3 for the E value                                             //选择指数e的值，默认值为65537，使用该选项则指数指定为3</span></span><br><span class="line"><span class="string"> -engine e       use engine e, possibly a hardware device.                         //指定三方加密库或者硬件</span></span><br><span class="line"><span class="string"> -rand file:file:...</span></span><br><span class="line"><span class="string">                 load the file (or the files in the directory) into                //产生随机数的种子文件</span></span><br><span class="line"><span class="string">                 the random number generator</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;通过上面的使用介绍我们来创建一个私钥，我们指定私钥的加密算法为aes128，创建密码为123456（在使用私钥时需要输入密码，如果设置了创建密码），密钥位数为2048位。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">openssl genrsa -aes128 -out rsa_2048.pem -passout pass:123456 2048</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在创建rsa私钥的时候是必须设置口令的，此密码用于加密私钥文件。以后在使用openssl提供的命令或者api再操作此私钥文件时需要输入口令。如果觉得输入口令不方便，也可以通过如下命令将口令去除：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">openssl rsa -in rsa_2048.pem -out rsa_2048.pem</span><br></pre></td></tr></table></figure>

<h3 id="openssl-rsa-命令介绍"><a href="#openssl-rsa-命令介绍" class="headerlink" title="openssl rsa 命令介绍"></a>openssl rsa 命令介绍</h3><p>rsa指令用户管理生成的密钥，其用法如下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xxx@cmos:~$ openssl rsa -</span><br><span class="line">unknown option -</span><br><span class="line">rsa [options] &lt;infile &gt;outfile     </span><br><span class="line"><span class="built_in">where</span> options are</span><br><span class="line"> -inform arg     input format - one of DER NET PEM                      //输入文件格式，默认pem格式</span><br><span class="line"> -outform arg    output format - one of DER NET PEM                     //输入文件格式，默认pem格式</span><br><span class="line"> -<span class="keyword">in</span> arg         input file                                             //输入文件</span><br><span class="line"> -sgckey         Use IIS SGC key format                                 //指定SGC编码格式，兼容老版本，不应再使用</span><br><span class="line"> -passin arg     input file pass phrase <span class="built_in">source</span>                          //指定输入文件的加密口令，可来自文件、终端、环境变量等</span><br><span class="line"> -out arg        output file                                            //输出文件</span><br><span class="line"> -passout arg    output file pass phrase <span class="built_in">source</span>                         //指定输出文件的加密口令，可来自文件、终端、环境变量等</span><br><span class="line"> -des            encrypt PEM output with cbc des                        //使用des加密输出的文件</span><br><span class="line"> -des3           encrypt PEM output with ede cbc des using 168 bit key  //使用des3加密输出的文件</span><br><span class="line"> -seed           encrypt PEM output with cbc seed                       //使用seed加密输出的文件</span><br><span class="line"> -aes128, -aes192, -aes256</span><br><span class="line">                 encrypt PEM output with cbc aes                        //使用aes加密输出的文件</span><br><span class="line"> -camellia128, -camellia192, -camellia256</span><br><span class="line">                 encrypt PEM output with cbc camellia                   //使用camellia加密输出的文件呢</span><br><span class="line"> -text           <span class="built_in">print</span> the key <span class="keyword">in</span> text                                  //以明文形式输出各个参数值</span><br><span class="line"> -noout          don<span class="string">'t print key out                                    //不输出密钥到任何文件</span></span><br><span class="line"><span class="string"> -modulus        print the RSA key modulus                              //输出模数指</span></span><br><span class="line"><span class="string"> -check          verify key consistency                                 //检查输入密钥的正确性和一致性</span></span><br><span class="line"><span class="string"> -pubin          expect a public key in input file                      //指定输入文件是公钥</span></span><br><span class="line"><span class="string"> -pubout         output a public key                                    //指定输出文件是公钥</span></span><br><span class="line"><span class="string"> -engine e       use engine e, possibly a hardware device.              //指定三方加密库或者硬件</span></span><br><span class="line"><span class="string">xlzh@cmos:~$</span></span><br></pre></td></tr></table></figure>
<ol>
<li><p>rsa添加和去除密钥的保护口令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/*生成不加密的RSA密钥*/</span><br><span class="line">xxx@cmos:~/<span class="built_in">test</span>$ openssl genrsa -out RSA.pem</span><br><span class="line">Generating RSA private key, 512 bit long modulus</span><br><span class="line">..............++++++++++++</span><br><span class="line">.....++++++++++++</span><br><span class="line">e is 65537 (0x10001)</span><br><span class="line">/*为RSA密钥增加口令保护*/</span><br><span class="line">xxx@cmos:~/<span class="built_in">test</span>$ openssl rsa -<span class="keyword">in</span> RSA.pem -des3 -passout pass:123456 -out E_RSA.pem</span><br><span class="line">writing RSA key</span><br><span class="line">/*为RSA密钥去除口令保护*/</span><br><span class="line">xxx@cmos:~/<span class="built_in">test</span>$ openssl rsa -<span class="keyword">in</span> E_RSA.pem -passin pass:123456 -out P_RSA.pem</span><br><span class="line">writing RSA key</span><br><span class="line">/*比较原始后的RSA密钥和去除口令后的RSA密钥，是一样*/</span><br><span class="line">xxx@cmos:~/<span class="built_in">test</span>$ diff RSA.pem P_RSA.pem</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改密钥的保护口令与算法</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/*生成RSA密钥*/</span><br><span class="line">xxx@cmos:~/<span class="built_in">test</span>$ openssl genrsa -des3 -passout pass:123456 -out RSA.pem</span><br><span class="line">Generating RSA private key, 512 bit long modulus</span><br><span class="line">..................++++++++++++</span><br><span class="line">......................++++++++++++</span><br><span class="line">e is 65537 (0x10001)</span><br><span class="line">/*修改加密算法为aes128，口令是123456*/</span><br><span class="line">xxx@cmos:~/<span class="built_in">test</span>$ openssl rsa -<span class="keyword">in</span> RSA.pem -passin pass:123456 -aes128 -passout pass:123456 -out E_RSA.pem</span><br><span class="line">writing RSA key</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看密钥对中的各个参数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xxx@cmos:~/<span class="built_in">test</span>$ openssl rsa -<span class="keyword">in</span> RSA.pem -des -passin pass:123456 -text -noout</span><br></pre></td></tr></table></figure>
</li>
<li><p>提取密钥中的公钥并打印模数值(生成私钥后，一般第一步就是导出公钥)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/*提取公钥，用pubout参数指定输出为公钥*/</span><br><span class="line">xxx@cmos:~/<span class="built_in">test</span>$ openssl rsa -<span class="keyword">in</span> RSA.pem -passin pass:123456 -pubout -out pub.pem</span><br><span class="line">writing RSA key</span><br><span class="line">/*打印公钥中模数值*/</span><br><span class="line">xxx@cmos:~/<span class="built_in">test</span>$ openssl rsa -<span class="keyword">in</span> pub.pem -pubin -modulus -noout</span><br><span class="line">Modulus=C35E0B54041D78466EAE7DE67C1DA4D26575BC1608CE6A199012E11D10ED36E2F7C651D4D8B40D93691D901E2CF4E21687E912B77DCCE069373A7F6585E946EF</span><br></pre></td></tr></table></figure>
</li>
<li><p>转换密钥的格式</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/*把pem格式转化成der格式，使用outform指定der格式*/</span><br><span class="line">xxx@cmos:~/<span class="built_in">test</span>$ openssl rsa -<span class="keyword">in</span> RSA.pem -passin pass:123456 -des -passout pass:123456 -outform der -out rsa.der</span><br><span class="line">writing RSA key</span><br><span class="line">/*把der格式转化成pem格式，使用inform指定der格式*/</span><br><span class="line">xxx@cmos:~/<span class="built_in">test</span>$ openssl rsa -<span class="keyword">in</span> rsa.der -inform der -passin pass:123456 -out rsa.pem</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="openssl-rsautl-命令介绍"><a href="#openssl-rsautl-命令介绍" class="headerlink" title="openssl rsautl 命令介绍"></a>openssl rsautl 命令介绍</h3><p>&emsp;&emsp;前面介绍的genrsa与rsa命令是生成密钥与对密钥进行管理的命令，rsautl则是真正用于密钥交换和数字签名，实质上就是用公钥或者私钥进行加密。<br>&emsp;&emsp;而无论是使用公钥加密还是私钥加密，RSA每次能够加密的数据长度不能超过RSA密钥长度，并且根据具体的补齐方式不同输入的加密数据最大长度也不一样，而输出长度则总是跟RSA密钥长度相等。RSA不同的补齐方法对应的输入输入长度如下表：  </p>
<table>
<thead>
<tr>
<th align="left">数据补齐方式</th>
<th align="left">输入数据长度</th>
<th align="left">输出数据长度</th>
<th align="right">参数字符串</th>
</tr>
</thead>
<tbody><tr>
<td align="left">PKCS#1 v1.5</td>
<td align="left">少于(密钥长度-11)字节</td>
<td align="left">同密钥长度</td>
<td align="right">-pkcs</td>
</tr>
<tr>
<td align="left">PKCS#1 OAEP</td>
<td align="left">少于(密钥长度-11)字节</td>
<td align="left">同密钥长度</td>
<td align="right">-oaep</td>
</tr>
<tr>
<td align="left">PKCS#1 for SSLv23</td>
<td align="left">少于(密钥长度-11)字节</td>
<td align="left">同密钥长度</td>
<td align="right">-ssl</td>
</tr>
<tr>
<td align="left">不使用补齐</td>
<td align="left">同密钥长度</td>
<td align="left">同密钥长度</td>
<td align="right">-raw</td>
</tr>
</tbody></table>
<p>rsautl指令用法如下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xlzh@cmos:~$ openssl rsautl - </span><br><span class="line">Usage: rsautl [options]                  </span><br><span class="line">-<span class="keyword">in</span> file        input file                                           //输入文件</span><br><span class="line">-out file       output file                                          //输出文件</span><br><span class="line">-inkey file     input key                                            //输入的密钥</span><br><span class="line">-keyform arg    private key format - default PEM                     //指定密钥格式</span><br><span class="line">-pubin          input is an RSA public                               //指定输入的是RSA公钥</span><br><span class="line">-certin         input is a certificate carrying an RSA public key    //指定输入的是证书文件</span><br><span class="line">-ssl            use SSL v2 padding                                   //使用SSLv23的填充方式</span><br><span class="line">-raw            use no padding                                       //不进行填充</span><br><span class="line">-pkcs           use PKCS<span class="comment">#1 v1.5 padding (default)                    //使用V1.5的填充方式</span></span><br><span class="line">-oaep           use PKCS<span class="comment">#1 OAEP                                      //使用OAEP的填充方式</span></span><br><span class="line">-sign           sign with private key                                //使用私钥做签名</span><br><span class="line">-verify         verify with public key                               //使用公钥认证签名</span><br><span class="line">-encrypt        encrypt with public key                              //使用公钥加密</span><br><span class="line">-decrypt        decrypt with private key                             //使用私钥解密</span><br><span class="line">-hexdump        hex dump output                                      //以16进制dump输出</span><br><span class="line">-engine e       use engine e, possibly a hardware device.            //指定三方库或者硬件设备</span><br><span class="line">-passin arg    pass phrase <span class="built_in">source</span>                                    //指定输入的密码</span><br></pre></td></tr></table></figure>
<ol>
<li><p>使用rsautl进行加密与解密操作（公钥加密，私钥解密）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*生成RSA密钥*&#x2F;</span><br><span class="line">xxx@cmos:~&#x2F;test$ openssl genrsa -des3 -passout pass:123456 -out RSA.pem </span><br><span class="line">Generating RSA private key, 512 bit long modulus</span><br><span class="line">............++++++++++++</span><br><span class="line">...++++++++++++</span><br><span class="line">e is 65537 (0x10001)</span><br><span class="line">&#x2F;*提取公钥*&#x2F;</span><br><span class="line">xxx@cmos:~&#x2F;test$ openssl rsa -in RSA.pem -passin pass:123456 -pubout -out pub.pem </span><br><span class="line">writing RSA key</span><br><span class="line">&#x2F;*使用RSA作为密钥进行加密，实际上使用其中的公钥进行加密*&#x2F;</span><br><span class="line">xxx@cmos:~&#x2F;test$ openssl rsautl -encrypt -in plain.txt -inkey RSA.pem -passin pass:123456 -out enc.txt</span><br><span class="line">&#x2F;*使用RSA作为密钥进行解密，实际上使用其中的私钥进行解密*&#x2F;</span><br><span class="line">xxx@cmos:~&#x2F;test$ openssl rsautl -decrypt -in enc.txt -inkey RSA.pem -passin pass:123456 -out replain.txt</span><br><span class="line">&#x2F;*比较原始文件和解密后文件*&#x2F;</span><br><span class="line">xxx@cmos:~&#x2F;test$ diff plain.txt replain.txt </span><br><span class="line">&#x2F;*使用公钥进行加密*&#x2F;</span><br><span class="line">xxx@cmos:~&#x2F;test$ openssl rsautl -encrypt -in plain.txt -inkey pub.pem -pubin -out enc1.txt</span><br><span class="line">&#x2F;*使用RSA作为密钥进行解密，实际上使用其中的私钥进行解密*&#x2F;</span><br><span class="line">xxx@cmos:~&#x2F;test$ openssl rsautl -decrypt -in enc1.txt -inkey RSA.pem -passin pass:123456 -out replain1.txt</span><br><span class="line">&#x2F;*比较原始文件和解密后文件*&#x2F;</span><br><span class="line">xxx@cmos:~&#x2F;test$ diff plain.txt replain1.txt</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用rsautl进行签名和验证操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*提取PCKS8格式的私钥*&#x2F;</span><br><span class="line">xxx@cmos:~&#x2F;test$ openssl pkcs8 -topk8 -in RSA.pem -passin pass:123456 -out pri.pem -nocrypt</span><br><span class="line">&#x2F;*使用RSA密钥进行签名，实际上使用私钥进行加密*&#x2F;</span><br><span class="line">xxx@cmos:~&#x2F;test$ openssl rsautl -sign -in plain.txt -inkey RSA.pem -passin pass:123456 -out sign.txt</span><br><span class="line">&#x2F;*使用RSA密钥进行验证，实际上使用公钥进行解密*&#x2F;</span><br><span class="line">xxx@cmos:~&#x2F;test$ openssl rsautl -verify -in sign.txt -inkey RSA.pem -passin pass:123456 -out replain.txt</span><br><span class="line">&#x2F;*对比原始文件和签名解密后的文件*&#x2F;</span><br><span class="line">xxx@cmos:~&#x2F;test$ diff plain.txt replain.txt </span><br><span class="line">&#x2F;*使用私钥进行签名*&#x2F;</span><br><span class="line">xxx@cmos:~&#x2F;test$ openssl rsautl -sign -in plain.txt -inkey pri.pem  -out sign1.txt</span><br><span class="line">&#x2F;*使用公钥进行验证*&#x2F;</span><br><span class="line">xxx@cmos:~&#x2F;test$ openssl rsautl -verify -in sign1.txt -inkey pub.pem -pubin -out replain1.txt</span><br><span class="line">&#x2F;*对比原始文件和签名解密后的文件*&#x2F;</span><br><span class="line">xxx@cmos:~&#x2F;test$ cat plain replain1.txt</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这种使用方法其实还是对原文件的加密与解密操作，因为真正的签名与验签过程是需要给源文件进行摘要提取，然后对摘要进行签名，主要通过openssl dgst命令进行。</p>
</li>
</ol>
<h2 id="openssl-dgst签名与验签"><a href="#openssl-dgst签名与验签" class="headerlink" title="openssl dgst签名与验签"></a>openssl dgst签名与验签</h2><p>dgst指令用法介绍如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xxx@cmos:~&#x2F;test$ openssl dgst -</span><br><span class="line">unknown option &#39;-&#39;</span><br><span class="line">options are</span><br><span class="line">-c              to output the digest with separating colons        &#x2F;&#x2F;输出的摘要信息以分号隔离，和-hex同时使用</span><br><span class="line">-r              to output the digest in coreutils format           &#x2F;&#x2F;指定输出的格式</span><br><span class="line">-d              to output debug info                               &#x2F;&#x2F;输出BIO调试信息</span><br><span class="line">-hex            output as hex dump                                 &#x2F;&#x2F;以16进制打印输出结果</span><br><span class="line">-binary         output in binary form                              &#x2F;&#x2F;输出二进制结果</span><br><span class="line">-hmac arg       set the HMAC key to arg                            &#x2F;&#x2F;指定hmac的key</span><br><span class="line">-non-fips-allow allow use of non FIPS digest                       &#x2F;&#x2F;允许使用不符合fips标准的摘要算法</span><br><span class="line">-sign   file    sign digest using private key in file              &#x2F;&#x2F;执行签名操作，后面指定私钥文件</span><br><span class="line">-verify file    verify a signature using public key in file        &#x2F;&#x2F;执行验证操作，后面指定公钥文件，与prverfify不能同时使用</span><br><span class="line">-prverify file  verify a signature using private key in file       &#x2F;&#x2F;执行验证操作，后面指定密钥文件，与verfify不能同时使用</span><br><span class="line">-keyform arg    key file format (PEM or ENGINE)                    &#x2F;&#x2F;指定密钥文件格式，pem或者engine</span><br><span class="line">-out filename   output to filename rather than stdout              &#x2F;&#x2F;指定输出文件，默认标准输出</span><br><span class="line">-signature file signature to verify                                &#x2F;&#x2F;指定签名文件，在验证签名时使用</span><br><span class="line">-sigopt nm:v    signature parameter                                &#x2F;&#x2F;签名参数</span><br><span class="line">-hmac key       create hashed MAC with key                         &#x2F;&#x2F;制作一个hmac 使用key</span><br><span class="line">-mac algorithm  create MAC (not neccessarily HMAC)                 &#x2F;&#x2F;制作一个mac</span><br><span class="line">-macopt nm:v    MAC algorithm parameters or key                    &#x2F;&#x2F;mac算法参数或者key</span><br><span class="line">-engine e       use engine e, possibly a hardware device.          &#x2F;&#x2F;使用硬件或者三方加密库</span><br><span class="line">-md4            to use the md4 message digest algorithm            &#x2F;&#x2F;摘要算法使用md4</span><br><span class="line">-md5            to use the md5 message digest algorithm            &#x2F;&#x2F;摘要算法使用md5</span><br><span class="line">-ripemd160      to use the ripemd160 message digest algorithm      &#x2F;&#x2F;摘要算法使用ripemd160</span><br><span class="line">-sha            to use the sha message digest algorithm            &#x2F;&#x2F;摘要算法使用sha</span><br><span class="line">-sha1           to use the sha1 message digest algorithm           &#x2F;&#x2F;摘要算法使用sha1</span><br><span class="line">-sha224         to use the sha224 message digest algorithm         &#x2F;&#x2F;摘要算法使用sha223</span><br><span class="line">-sha256         to use the sha256 message digest algorithm         &#x2F;&#x2F;摘要算法使用sha256</span><br><span class="line">-sha384         to use the sha384 message digest algorithm         &#x2F;&#x2F;摘要算法使用sha384</span><br><span class="line">-sha512         to use the sha512 message digest algorithm         &#x2F;&#x2F;摘要算法使用sha512</span><br><span class="line">-whirlpool      to use the whirlpool message digest algorithm      &#x2F;&#x2F;摘要算法使用whirlpool</span><br></pre></td></tr></table></figure>
<p>使用RSA密钥进行签名验证操作:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">openssl dgst -sha256 -sign rsa_2048.pem -out stroptr.c.sign stroptr.c  <span class="comment"># 生成摘要签名</span></span><br><span class="line">openssl  dgst  -verify pub.pem -sha256 -signature stroptr.c.sign  stroptr.c <span class="comment"># 验证签名</span></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>openssl</tag>
      </tags>
  </entry>
  <entry>
    <title>printk_ratelimited 导致log打印不全</title>
    <url>/2020/06/30/printk-ratelimited/</url>
    <content><![CDATA[<p>在Android调试过程中，发现启动log中出现如下log：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[   48.471014] printk: init: 46 output lines suppressed due to ratelimiting</span><br><span class="line">[   48.617226] init: [libfs_mgr]dt_fstab: Skip disabled entry for partition vendor</span><br><span class="line">[   48.631023] init: [libfs_mgr]Warning: unknown flag: wrappedkey</span><br><span class="line">[   48.639762] init: DM_DEV_STATUS failed for system_ext: No such device or address</span><br><span class="line">[   48.647430] init: Could not update logical partition</span><br><span class="line">[   48.653314] init: DM_DEV_STATUS failed for product: No such device or address</span><br><span class="line">[   48.660748] init: Could not update logical partition</span><br></pre></td></tr></table></figure>
<p>也就是说<code>printk: init: 46 output lines suppressed due to ratelimiting</code>有部分log没有打印出来，解决办法就是修改kernel源码。修改文件位于<code>include/linux/ratelimit.h</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 下面表示5秒内最多打印10条记录，可以将DEFAULT_RATELIMIT_BURST修改成50，那么5秒内就可以打印50条了。当然也不是越大越好，因为需要考虑考log对系统服务器的影响，不要引起阻塞。</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFAULT_RATELIMIT_INTERVAL      (5 * HZ)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFAULT_RATELIMIT_BURST         10  <span class="comment">// 可以修改成50</span></span></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>kernel printk 调试</tag>
      </tags>
  </entry>
  <entry>
    <title>匿名命名空间与inline命名空间</title>
    <url>/2020/12/07/unnamed-inline-namespaces/</url>
    <content><![CDATA[<p>c/c++中除了正常使用的命名空间外，还提供了匿名命名空间与inline命名空间，这两种命名空间用在特殊的场合。</p>
<h3 id="匿名命名空间"><a href="#匿名命名空间" class="headerlink" title="匿名命名空间"></a>匿名命名空间</h3><p>匿名命名空间就是在<code>namespace</code>关键字后没有带名字标识符的命名空间，看如下例子。</p>
<a id="more"></a>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> &#123; <span class="comment">// 匿名命名空间</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"v1\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    doSomething();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的例子会正常输出：<br><code>v1</code><br>官方的说法是，所有的匿名命名空间中定义的内容，都会作为其父命名空间的一部分。所以在上面例子中的<code>main</code>函数中可以调用匿名命名空间中的内容，但是在定义该命名空间的文件外<code>doSomething</code>不可见。所以命名空间的作用相同与<code>static</code>作用。</p>
<h3 id="inline命名空间"><a href="#inline命名空间" class="headerlink" title="inline命名空间"></a>inline命名空间</h3><p><code>inline命名空间</code>经常用于对同一函数的多个版本管理。看下面的例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">namespace</span> v1 &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; 'v1\n';</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> v2 &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"v2\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    v1::doSomething(); <span class="comment">// 调用v1命名空间的doSomething()函数</span></span><br><span class="line">    v2::doSomething(); <span class="comment">// 调用v2命名空间的doSomething()函数</span></span><br><span class="line">    doSomething(); <span class="comment">// 调用inline命名空间中的函数v1::doSomething()</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的例子中可以看到，同一文件中，不加命名空间默认调用<code>inline 命名空间</code>中的内容，如果新的版本的函数定义的普通命名空间中，加上命名空间名字调用即可。</p>
]]></content>
      <tags>
        <tag>c/c++</tag>
      </tags>
  </entry>
  <entry>
    <title>如何解压android系统镜像</title>
    <url>/2020/05/18/unpack-filesystem-data/</url>
    <content><![CDATA[<p>&emsp;&emsp;在android的开发过程中，经常需要用到将andorid system.img 或者 vendor.img等ext文件系统格式的镜像给解压出来分析，如果当前Linux系统有root权限，那么可以直接mount 镜像来进行提取，但是一般开发服务器是不提供root权限的，所以本文讨论如何在没有root权限的情况下对文件系统镜像进行提取。以AndroidQ super.img为例进行说明。</p>
<a id="more"></a>

<h2 id="super-img"><a href="#super-img" class="headerlink" title="super.img"></a>super.img</h2><p>&emsp;&emsp;super.img是AndroidQ引入的，用于处理动态分区特性。例如将system、vendor<br>、product分区定义为动态分区，那么编译完成时这三个分区的镜像就会合并成一个super.img镜像，当然也能将super.img拆分成system.img、vendor.img、product.img镜像。</p>
<h3 id="如何拆分super-img"><a href="#如何拆分super-img" class="headerlink" title="如何拆分super.img"></a>如何拆分super.img</h3><p>&emsp;&emsp;Android Q 自带了lpunpack工具来对super.img进行解压。下面是lpunpack的使用介绍。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./lpunpack - <span class="built_in">command</span>-line tool <span class="keyword">for</span> extracting partition images from super</span><br><span class="line"></span><br><span class="line">Usage:</span><br><span class="line">  ./lpunpack [options...] SUPER_IMAGE [OUTPUT_DIR]</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -p, --partition=NAME     Extract the named partition. This can</span><br><span class="line">                           be specified multiple <span class="built_in">times</span>.</span><br><span class="line">  -S, --slot=NUM           Slot number (default is 0).</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;例如：<code>lpunpack super.img</code>默认会将所有的分区文件提取出来，可以通过-p选择提取指定的分区镜像。需要注意的是，lpunpack工具aosp代码默认不会编译，可以通过将lpunpack加入PRODUCT_HOST_PACKAGES，然后编译，源码在aosp源码的system/extras/partition_tools目录。<br>&emsp;&emsp;aosp源码的system/extras/partition_tools目录下面还有几个常用工具，一起介绍下。<br>lpmake：用于生成一个super.img文件，具体使用方法可以通过<code>lpmake -h</code>查看。<br>lpdump：用于dump一个super.img文件中包含哪些分区等元数据。<br>lpflash：用于烧录镜像到设备，<code>Usage: lpflash /dev/block/sdX /path/to/image/file</code>。</p>
<h2 id="如何拆分system-img"><a href="#如何拆分system-img" class="headerlink" title="如何拆分system.img"></a>如何拆分system.img</h2><p>&emsp;&emsp;通过上个步骤的lpunpack后，会得到system.img.如果system.img镜像的格式是sparse格式的（super.img解压后的不需要这个步骤，已经是raw格式的了），需要将其转换为raw格式，转换工具为<code>simg2img</code>，在aosp编译后的out/host/linux-x86/bin目录，转换命令如下:  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">simg2img system.img  system.img.raw</span><br></pre></td></tr></table></figure>
<p>system.img一般为ext文件系统，这里以ext文件系统解压作为讲解。最常用的方法就是使用e2fsprogs中的debugfs了。比如想将system.img中的内容解压到system目录，使用debugfs的命令如下:  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir system</span><br><span class="line">debugfs system.img  -R <span class="string">"rdump / system"</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;还有一种方法是使用nlitsme提供的extfstools工具，在github上有下载该工具的源码。但是extfstools依赖c++17与boost库，所以需要先编译gcc 6以上的版本与boost库。</p>
<h3 id="编译gcc"><a href="#编译gcc" class="headerlink" title="编译gcc"></a>编译gcc</h3><p>&emsp;&emsp;在gcc 6以上的对c++17的特性支持比较全，关于gcc对c++版本的支持查看<a href="https://zh.cppreference.com/w/cpp/compiler_support" target="_blank" rel="noopener">这里</a>。所以选取了gcc-6.2.0，下载地址点<a href="https://ftp.gnu.org/gnu/gcc/gcc-6.2.0/gcc-6.2.0.tar.bz2" target="_blank" rel="noopener">这里</a>。  </p>
<ol>
<li>配置gcc  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir build install</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">../$(gcc-source-scode-dir)/configure --prefix=&lt;install目录的绝对路径&gt; --<span class="built_in">enable</span>-languages=c,c++</span><br></pre></td></tr></table></figure>
执行上面步骤的时候可能会出现如下报错:  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">checking for objdir... .libs</span><br><span class="line">checking for the correct version of gmp.h... no</span><br><span class="line">configure: error: Building GCC requires GMP 4.2+, MPFR 2.4.0+ and MPC 0.8.0+.</span><br><span class="line">Try the --with-gmp, --with-mpfr and&#x2F;or --with-mpc options to specify</span><br><span class="line">their locations.  Source code for these libraries can be found at</span><br><span class="line">their respective hosting sites as well as at</span><br><span class="line">ftp:&#x2F;&#x2F;gcc.gnu.org&#x2F;pub&#x2F;gcc&#x2F;infrastructure&#x2F;.  See also</span><br><span class="line">http:&#x2F;&#x2F;gcc.gnu.org&#x2F;install&#x2F;prerequisites.html for additional info.  If</span><br><span class="line">you obtained GMP, MPFR and&#x2F;or MPC from a vendor distribution package,</span><br><span class="line">make sure that you have installed both the libraries and the header</span><br><span class="line">files.  They may be located in separate packages.</span><br></pre></td></tr></table></figure>
解决方法是到gcc源码目录执行<code>./contrib/download_prerequisites</code>，然后重新配置gcc。</li>
<li>编译与安装<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make -j32</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="编译boost"><a href="#编译boost" class="headerlink" title="编译boost"></a>编译boost</h3><p>&emsp;&emsp;boost的新版本下载地址请点击<a href="https://dl.bintray.com/boostorg/release/1.73.0/source/boost_1_73_0.tar.bz2" target="_blank" rel="noopener">这里</a>。关于新手怎么使用boost可以查看<a href="https://www.boost.org/doc/libs/1_73_0/more/getting_started/unix-variants.html" target="_blank" rel="noopener">官方文档</a>。</p>
<ol>
<li>配置boost  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> &lt;bost_source_dir&gt;</span><br><span class="line">mkdir install</span><br><span class="line">./bootstrap.sh --with-toolset=gcc --prefix=&lt;Absolute address <span class="keyword">for</span> bost_source_dir&gt;/install --with-libraries=all</span><br></pre></td></tr></table></figure></li>
<li>编译与安装  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./b2 install</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="编译extfstools"><a href="#编译extfstools" class="headerlink" title="编译extfstools"></a>编译extfstools</h3><p>&emsp;&emsp;extfstools可以通过git命令从github<a href="https://github.com/nlitsme/extfstools.git" target="_blank" rel="noopener">地址</a>下载。由于我们的gcc与boost是安装的自定义目录，没有安装到系统目录，所以需要修改extfstools/Makefile来指定环境变量。在<code>CXXFLAGS</code>中加入<code>-I &lt;Absolute address for bost_source_dir&gt;/install/include</code>,在<code>LDFLAGS</code>中添加<code>-Wl,-rpath,&#39;$$ORIGIN/lib64&#39;</code>。这里修改链接选项的目的是使用我们新编译的gcc库。  </p>
<ol>
<li><p>拷贝gcc标准库  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> &lt;extfstools <span class="built_in">source</span> dir&gt;</span><br><span class="line">mkdir lib64</span><br><span class="line"><span class="built_in">cd</span> lib64</span><br><span class="line">cp &lt;gcc install path&gt;/libgcc_s.so.1 libgcc_s.so.1</span><br><span class="line">cp &lt;gcc install path&gt;/libstdc++.so.6.0.22 libstdc++.so.6.0.22</span><br><span class="line">ln -s libstdc++.so.6.0.22 libstdc++.so.6</span><br><span class="line"><span class="built_in">cd</span> -</span><br></pre></td></tr></table></figure>
</li>
<li><p>编译  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CXX=&lt;gcc install path&gt;/g++ make clean</span><br><span class="line">CXX=&lt;gcc install path&gt;/g++ make -j32</span><br></pre></td></tr></table></figure>
<p>编译完成后，执行<code>./ext2rd --help</code>会打印如果使用说明：<br><img src="/images/ext2rd_help.png" alt=""><br>解压system.img:  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./ext2rd system.img  ./:system</span><br></pre></td></tr></table></figure>
<p>解压效果如下图:<br><img src="/images/system_filelist.png" alt=""></p>
</li>
</ol>
]]></content>
      <tags>
        <tag>android filesystem</tag>
      </tags>
  </entry>
  <entry>
    <title>c/c++ 递归</title>
    <url>/2021/01/20/cpp-Recursion/</url>
    <content><![CDATA[<p>c/c++中，递归函数就是一个调用自身的函数。由于递归函数需要调用自身，所以如果函数没有退出或者终止调用的条件的话，那么将会导致不断的调用自身，栈内存将会被耗尽。看下面的例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">countDown</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"push "</span> &lt;&lt; <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    countDown(count<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    countDown(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子中，<code>countDown</code>函数没有终止调用条件，会无限制调用下去，最终导致栈溢出。要编写一个正常的递归函数，那么该函数必须要有终止调用的条件。</p>
<a id="more"></a>

<h4 id="递归终止条件"><a href="#递归终止条件" class="headerlink" title="递归终止条件"></a>递归终止条件</h4><p><code>递归终止条件</code>是一个能够终止递归函数调用自身的条件。通常情况下，<code>递归终止条件</code>通过if语句调用。将上面的例子，改写成如下的例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">countDown</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"push "</span> &lt;&lt; <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        countDown(count<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"pop "</span> &lt;&lt; <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    countDown(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码会生成如下的输出:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">push 5</span><br><span class="line">push 4</span><br><span class="line">push 3</span><br><span class="line">push 2</span><br><span class="line">push 1</span><br><span class="line">push 0</span><br><span class="line">pop 0</span><br><span class="line">pop 1</span><br><span class="line">pop 2</span><br><span class="line">pop 3</span><br><span class="line">pop 4</span><br><span class="line">pop 5</span><br></pre></td></tr></table></figure>
<p>可以看到，在递归函数之前的代码是顺序运行的，而在递归函数之后的代码是倒序运行的。</p>
<h4 id="递归应用"><a href="#递归应用" class="headerlink" title="递归应用"></a>递归应用</h4><p>下面介绍几个递归应用的例子。  </p>
<ol>
<li><p>计算正数的阶乘。<br>n! = n*(n-1)*…*2*1。<br>递归终止条件: 0! = 1</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">factorial</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> num*factorial(num<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sample = factorial(<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"3! = "</span> &lt;&lt; sample &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>计算一个正整数的各位的和。(例如：964: 9+6+4=19)<br>递归终止条件: n&lt;10,return n%10</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">10</span>)</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">return</span> count(n/<span class="number">10</span>) + n%<span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sample[]&#123;<span class="number">2345</span>,<span class="number">55677</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> s : sample) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="string">"==========&gt; "</span> &lt;&lt; count(s) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是需要保存结果的情况:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; record;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">10</span>) &#123;</span><br><span class="line">        record.<span class="built_in">clear</span>();</span><br><span class="line">        record.push_back(n);</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    r = count(n/<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">int</span> y = n%<span class="number">10</span>;</span><br><span class="line">    record.push_back(y);</span><br><span class="line">    <span class="keyword">return</span> r+y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sample[]&#123;<span class="number">2345</span>,<span class="number">55677</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"test ....\n"</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> s : sample) &#123;</span><br><span class="line">        count(s);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> r : record)</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="string">"==========&gt; "</span> &lt;&lt; r &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>以二进制形式显示一个正数。（如：9： 1001）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; record;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binary</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;=<span class="number">1</span> ) &#123;</span><br><span class="line">        record.<span class="built_in">clear</span>();</span><br><span class="line">        record.push_back(x);</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">int</span> bin = binary(x/<span class="number">2</span>);</span><br><span class="line">    record.push_back(x%<span class="number">2</span>); <span class="comment">// 放在递归之后，调用是倒序的</span></span><br><span class="line">    <span class="keyword">return</span> bin;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> test[]&#123;<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> t : test) &#123;</span><br><span class="line">        binary(t);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> r : record) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如何处理负数呢？可以将binary函数的形参类型改为<code>unsinged int</code>类型，这样最高位就表示符号位了。  </p>
</li>
</ol>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>应该尽量少用递归，而应该看是否能够通过循环来解决问题。</p>
]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
      </tags>
  </entry>
  <entry>
    <title>编译kernel外部模块</title>
    <url>/2021/01/25/build-external-modules-kernel/</url>
    <content><![CDATA[<p>本文翻译自kernel<a href="https://www.kernel.org/doc/html/v5.4/kbuild/modules.html" target="_blank" rel="noopener">官方文档</a>,介绍怎么编译kernel源码目录之外的代码模块。  </p>
<h4 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1 介绍"></a>1 介绍</h4><p>Linux kernel使用<code>kbuild编译系统</code>来编译。kernel模块编译需要保持kbuild架构兼容，并且选择正确的gcc编译flag。kernel编译系统提供了在源码目录内编译以及在源码目录外编译的功能。这两种编译方式是类似的，所有的模块在最初开发阶段都是在源码外编译的。<br>本文所涵盖内容的目标是那些对在kernel源码目录之外编译模块感兴趣的开发者。源码目录外的模块的开发者应该提供一个makefile,该makefile隐藏了很多复杂细节，编译时只需要执行make命令就可以编译该模块。这个很容易实现，在第3小节会有一个详细的示例。</p>
<a id="more"></a>

<h4 id="2-怎么编译外部模块"><a href="#2-怎么编译外部模块" class="headerlink" title="2 怎么编译外部模块"></a>2 怎么编译外部模块</h4><p>为了编译外部模块，必要条件是需要有一个已经编译过的kernel代码。同时kernel config中需要使能模块加载（CONFIG_MODULE）。如果你使用的是发行版内核，发行版将提供内核的软件包。<br>另外一种方法是使用<code>make modules_prepare</code>命令。这个命令能够保证编译外部模块所需要的依赖都已经被编译出来。<code>modules_prepare</code>这个目标就是抓门用于为编译外部模块而准备的。<br>注意：即使设置了CONFIG_MODVERSIONS，“ modules_prepare”也不会构建Module.symvers。 因此，需要执行完整的内核编译以使模块版本控制工作。  </p>
<h5 id="2-1-编译命令"><a href="#2-1-编译命令" class="headerlink" title="2.1 编译命令"></a>2.1 编译命令</h5><p>下面的编译命令用于编译外部模块:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ make -C &lt;path_to_kernel_src&gt; M=<span class="variable">$PWD</span></span><br></pre></td></tr></table></figure>
<p><code>Kbuild编译系统</code>通过编译命令中的<code>M=&lt;dir&gt;</code>来确定当前需要编译哪个模块。<br>如果要针对当前正在运行的内核进行编译使用如下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ make -C /lib/modules/`uname -r`/build M=<span class="variable">$PWD</span></span><br></pre></td></tr></table></figure>
<p>要安装刚刚构建的模块，请将目标“ modules_install”添加到命令中：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ make -C /lib/modules/`uname -r`/build M=<span class="variable">$PWD</span> modules_install</span><br></pre></td></tr></table></figure>

<h5 id="2-2-编译选项"><a href="#2-2-编译选项" class="headerlink" title="2.2 编译选项"></a>2.2 编译选项</h5><p>($KDIR表示内核源码路径。)<br>make -C $KDIR M=$PWD  </p>
<h6 id="C-KDIR"><a href="#C-KDIR" class="headerlink" title="-C $KDIR"></a>-C $KDIR</h6><p>kernel源码所在目录。make -C执行时，实际上会先到$KDIR目录执行，然后再返回。</p>
<h6 id="M-PWD"><a href="#M-PWD" class="headerlink" title="M=$PWD"></a>M=$PWD</h6><p>通知kbuild一个外部模块即将编译。“M”的值是外部模块（kbuild文件）所在目录的绝对路径。</p>
<h5 id="2-3-编译目标"><a href="#2-3-编译目标" class="headerlink" title="2.3 编译目标"></a>2.3 编译目标</h5><p>在构建外部模块时，仅“make”目标的子集可用。也就是说不是所有的kernel编译命令都可以在外部模块目录下执行。<br>make -C $KDIR M=$PWD [target]<br>默认情况下会编译当前目录的模块，所以不需要指定任何目标。所有的编译输出都将输出在$PWD目录。但是执行时，内核源码不能被更新，这是外部模块成功编译的前提。  </p>
<h6 id="modules"><a href="#modules" class="headerlink" title="modules"></a>modules</h6><p><code>modules</code>是编译外部模块时的默认目标。即使没有指定任何目标，也会执行这个目标的编译动作。  </p>
<h6 id="modules-install"><a href="#modules-install" class="headerlink" title="modules_install"></a>modules_install</h6><p>该目标用于安装外部模块。模块默认安装路径为/lib/modules/<kernel_release>/extra/,但是也可以通过INSTALL_MOD_PATH来指定。</p>
<h6 id="clean"><a href="#clean" class="headerlink" title="clean"></a>clean</h6><p>清除模块目录中生成的所有文件。</p>
<h6 id="help"><a href="#help" class="headerlink" title="help"></a>help</h6><p>列举所有支持的目标。 </p>
<h5 id="2-4-编译单独的文件"><a href="#2-4-编译单独的文件" class="headerlink" title="2.4 编译单独的文件"></a>2.4 编译单独的文件</h5><p>内核中可以通过命令单独编译组成一个模块的单独文件。这个对整个kernel源码还是外部模块都是生效的。看下面的例子：（foo.ko由bar.o、baz.o组成）:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make -C $KDIR M&#x3D;$PWD bar.lst</span><br><span class="line">make -C $KDIR M&#x3D;$PWD baz.o</span><br><span class="line">make -C $KDIR M&#x3D;$PWD foo.ko</span><br><span class="line">make -C $KDIR M&#x3D;$PWD .&#x2F;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>编译</category>
        <category>kernel</category>
      </categories>
      <tags>
        <tag>kernel</tag>
        <tag>编译</tag>
      </tags>
  </entry>
  <entry>
    <title>c++构造函数</title>
    <url>/2021/01/29/cpp-constructors/</url>
    <content><![CDATA[<p>c++构造函数是类中的一个特殊的成员函数，它在类实例化的时候被自动调用。构造函数经常用于初始化成员变量，或者做一些初始化步骤(如打开文件，打开数据库等)。区别于普通成员函数，构造函数有如下特点:</p>
<ul>
<li>构造函数名字跟类名相同</li>
<li>构造函数没有返回值</li>
</ul>
<h5 id="关于对象初始化"><a href="#关于对象初始化" class="headerlink" title="关于对象初始化"></a>关于对象初始化</h5><p>关于对象初始化，有几种方式，看下面的例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_x;</span><br><span class="line">    <span class="keyword">int</span> m_y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Foo foo1 = &#123;<span class="number">4</span>, <span class="number">5</span>&#125;; <span class="comment">//  initialization list</span></span><br><span class="line">    Foo foo2 &#123;<span class="number">6</span>, <span class="number">7</span>&#125;; <span class="comment">//  uniform initialization</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在没有显示定义构造函数的情况下，可以使用上面的初始化方式初始化<code>public</code>类型的成员变量。如果成员变量是<code>private</code>的，那么就需要自定义构造函数了。  </p>
<p>看下的关于构造函数的定义方法:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fraction</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_numerator;</span><br><span class="line">    <span class="keyword">int</span> m_denominator;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Fraction() <span class="comment">// default constructor</span></span><br><span class="line">    &#123;</span><br><span class="line">         m_numerator = <span class="number">0</span>;</span><br><span class="line">         m_denominator = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Constructor with two parameters, one parameter having a default value</span></span><br><span class="line">    Fraction(<span class="keyword">int</span> numerator, <span class="keyword">int</span> denominator=<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        assert(denominator != <span class="number">0</span>);</span><br><span class="line">        m_numerator = numerator;</span><br><span class="line">        m_denominator = denominator;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getNumerator</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_numerator; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getDenominator</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_denominator; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(m_numerator) / m_denominator; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面的类可以通过如下方法进行实例化:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Fraction fiveThirds&#123;<span class="number">5</span>, <span class="number">3</span>&#125;; <span class="comment">// List initialization, calls Fraction(int, int)</span></span><br><span class="line"><span class="function">Fraction <span class="title">threeQuarters</span><span class="params">(<span class="number">3</span>, <span class="number">4</span>)</span></span>; <span class="comment">// Direct initialization, also calls Fraction(int, int)</span></span><br></pre></td></tr></table></figure>
<p>上面的实例化使用了大括号和小括号两种初始化方式，一般情况下我们应该使用大括号初始化。  </p>
<p>下面是一个对构造函数默认参数使用的例子:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ball</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> m_color;</span><br><span class="line">    <span class="keyword">float</span> m_radius;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Ball(<span class="built_in">std</span>::<span class="built_in">string</span> color=<span class="string">"black"</span>, <span class="keyword">float</span> radius=<span class="number">10.0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        assert(radius &gt; <span class="number">0</span>);</span><br><span class="line">        m_color = color;</span><br><span class="line">        m_radius = radius;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Ball(<span class="keyword">float</span> radius)</span><br><span class="line">    &#123;</span><br><span class="line">        assert(radius &gt; <span class="number">0</span>);</span><br><span class="line">        m_color = <span class="string">"black"</span>;</span><br><span class="line">        m_radius = radius;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"color: "</span> &lt;&lt; m_color &lt;&lt; <span class="string">", radius: "</span> &lt;&lt; m_radius &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Ball def&#123;&#125;;</span><br><span class="line">    def.<span class="built_in">print</span>();</span><br><span class="line"> </span><br><span class="line">    Ball blue&#123; <span class="string">"blue"</span> &#125;;</span><br><span class="line">    blue.<span class="built_in">print</span>();</span><br><span class="line">    </span><br><span class="line">    Ball twenty&#123; <span class="number">3.5</span> &#125;;</span><br><span class="line">    twenty.<span class="built_in">print</span>();</span><br><span class="line">    </span><br><span class="line">    Ball blueTwenty&#123; <span class="string">"blue"</span>, <span class="number">20.0</span> &#125;;</span><br><span class="line">    blueTwenty.<span class="built_in">print</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="类内包含类情况的构造函数调用"><a href="#类内包含类情况的构造函数调用" class="headerlink" title="类内包含类情况的构造函数调用"></a>类内包含类情况的构造函数调用</h5><p>一个类内可能包含成员类型是其它类类型的情况。默认情况下，当类初始化时，会先调用类类型成员的构造函数。看下面的例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"A\n"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    A m_a; <span class="comment">// B contains A as a member variable</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    B() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"B\n"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    B b;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的例子会输出：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">A</span><br><span class="line">B</span><br></pre></td></tr></table></figure>

<h5 id="构造函数需要注意的地方"><a href="#构造函数需要注意的地方" class="headerlink" title="构造函数需要注意的地方"></a>构造函数需要注意的地方</h5><ol>
<li>如果没有定义构造函数，那么编译器会默认为类创建一个空构造函数，所以该类还是可以被实例化</li>
<li>如果程序员手动为类定义了构造函数，那么编译器将不会为类自动创建构造函数了，所以如果程序员实现了带参数的构造函数，没有实现无参构造函数，那么在实例化的时候将不能使用不带参数实例化。这种情况下可以使用<code>&lt;class&gt;()=default</code>添加一个默认的构造函数。</li>
<li>在编写程序时，应该在构造函数中初始化所有的内部成员变量。</li>
<li>尽量减少类的构造函数数量</li>
<li>需要注意，实例(对象)并不是构造函数创建的，实例是编译器在内存中创建的，然后才调用构造函数。</li>
</ol>
]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
      </tags>
  </entry>
  <entry>
    <title>go语言中的环境变量</title>
    <url>/2021/01/29/go-environment/</url>
    <content><![CDATA[<p>GO语言开发环境搭建过程中，有三个环境变量是需要设置的。下面描述下三个环境变量代表的含义。</p>
<ul>
<li>GOROOR: Go语言环境的安装目录，也就是从官网下载开发环境时，安装到的本地路径。例如<code>C:\Go\</code>。</li>
<li>GOPATH: Go开发时的工作区目录的路径。这是开发每个Go项目时定义的变量。</li>
<li>GOBIN: Go程序执行路径。</li>
</ul>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>c++中的struct与class</title>
    <url>/2021/01/28/cpp-strcut-and-class/</url>
    <content><![CDATA[<p>在c++中既可以使用strcut也可以使用class。那么他们有什么区别呢？看下面的例子。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DateStruct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> year&#123;&#125;;</span><br><span class="line">    <span class="keyword">int</span> month&#123;&#125;;</span><br><span class="line">    <span class="keyword">int</span> day&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DateClass</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_year&#123;&#125;;</span><br><span class="line">    <span class="keyword">int</span> m_month&#123;&#125;;</span><br><span class="line">    <span class="keyword">int</span> m_day&#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>c++中，上面定义的DateStruct与DateClass是一样的，也就是说DateSruct中的成员类型是<code>public</code>的。注意上面只是申明了两个了类型，并没有定义，所以不会分配内存。</p>
<a id="more"></a>

<h5 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h5><p>除了了数据，class或者sruct还可以包含函数。定义在类中的函数叫做成员函数或者方法。成员函数可以定义在类里面，也可以定义的类定义外面。看下面的示例:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DateStruct</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_year&#123;&#125;;</span><br><span class="line">    <span class="keyword">int</span> m_month&#123;&#125;;</span><br><span class="line">    <span class="keyword">int</span> m_day&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; m_year &lt;&lt; <span class="string">'-'</span> &lt;&lt; m_month &lt;&lt; <span class="string">'-'</span> &lt;&lt; m_day &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>跟结构体的使用一样，类使用选择运算符(<code>.</code>)来访问类中的变量与成员函数。<br>成员变量使用”m_”前缀进行命名，以区分函数形参与函数局部变量。这个命名规则很有用。首先，当我们看到对带有“ m_”前缀的变量的赋值时，我们知道我们正在更改类实例的状态。 其次，与在函数中声明的函数参数或局部变量不同，成员变量在类定义中声明。 因此，如果我们想知道如何声明带有“ m_”前缀的变量，我们知道应该在类定义中查找而不是在函数中查找。另外，按照约定，类名应以大写字母开头。</p>
<h5 id="使用规则"><a href="#使用规则" class="headerlink" title="使用规则"></a>使用规则</h5><p>如果某个抽象只包含数据不包含方法，使用<code>struct</code>，如果包含函数，那么使用<code>class</code>。</p>
]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
      </tags>
  </entry>
  <entry>
    <title>c++析构函数</title>
    <url>/2021/02/26/cpp-destructor/</url>
    <content><![CDATA[<p>c++中析构函数跟构造函数是相对于应的，构造函数在对象创建时调用，析构函数在对象销毁时调用。析构函数有如下特点：</p>
<ol>
<li>析构函数名字与类名相同，函数名前面需要加上<code>~</code></li>
<li>析构函数不带任何参数。（所以不能重载，所以析构函数只有有一个）</li>
<li>析构函数没有返回值</li>
</ol>
<p>析构函数一般用于释放构造函数中申请的资源，如动态内存、文件句柄、数据库句柄等。</p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>c++ friend 关键字</title>
    <url>/2021/03/01/cpp-friend/</url>
    <content><![CDATA[<p>c++中friend关键字用于使得不在本类中的成员函数能够访问本类的私有成员变量。分为三种情况:</p>
<ul>
<li>某个外部函数，利用friend关键字能够访问本类中的私有成员变量</li>
<li>另一个类中的所有成员函数通过friend关键字能够访问本类中的私有成员变量。</li>
<li>另一个类中的某个成员函数通过friend关键字能够访问本类中的私有成员变量，另一个类中的其他成员函数不能访问本类中的私有成员变量。<a id="more"></a>

</li>
</ul>
<p>先看看第一种情况，外部函数能够访问本类的私有成员变量。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Accumulator</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Accumulator() &#123; m_value = <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123; m_value += value; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 申明能够访问该类内部私有成员的函数</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">(Accumulator &amp;accmulator)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过上面的申明，rest函数已经是Accumulator类的友元函数了</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">(Accumulator &amp;accmulator)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    accmulator.m_value = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Accumulator acc;</span><br><span class="line">    acc.add(<span class="number">5</span>);</span><br><span class="line">    reset(acc);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意上面<code>reset</code>函数的定义，reset函数因为是外部函数，所以是拿不到Accumulator类的*this指针的，所以需要传入Accumulator作为其参数。  </p>
<p>接下来看第二种，情况友元类，该情况下第一个类是第二个类的友元类，所以第二个类可以访问第一个类的私有成员变量。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector3d</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> m_x&#123;&#125;;</span><br><span class="line">    <span class="keyword">double</span> m_y&#123;&#125;;</span><br><span class="line">    <span class="keyword">double</span> m_z&#123;&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Vector3d(<span class="keyword">double</span> x = <span class="number">0.0</span>, <span class="keyword">double</span> y = <span class="number">0.0</span>, <span class="keyword">double</span> z = <span class="number">0.0</span>)</span><br><span class="line">        : m_x&#123;x&#125;, m_y&#123;y&#125;, m_z&#123;z&#125;</span><br><span class="line">    &#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Vector("</span> &lt;&lt; m_x &lt;&lt; <span class="string">" , "</span> &lt;&lt; m_y &lt;&lt; <span class="string">" , "</span> &lt;&lt; m_z &lt;&lt; <span class="string">")\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 申明友元类</span></span><br><span class="line">    <span class="comment">// 申明Point3d是Vector3d的友元类，所以Point3d可以访问Vector3d中的私有成员</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Point3d</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point3d</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> m_x&#123;&#125;;</span><br><span class="line">    <span class="keyword">double</span> m_y&#123;&#125;;</span><br><span class="line">    <span class="keyword">double</span> m_z&#123;&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Point3d(<span class="keyword">double</span> x = <span class="number">0.0</span>, <span class="keyword">double</span> y = <span class="number">0.0</span>, <span class="keyword">double</span> z = <span class="number">0.0</span>)</span><br><span class="line">        : m_x&#123;x&#125;, m_y&#123;y&#125;, m_z&#123;z&#125;</span><br><span class="line">    &#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Point("</span> &lt;&lt; m_x &lt;&lt; <span class="string">" , "</span> &lt;&lt; m_y &lt;&lt; <span class="string">" , "</span> &lt;&lt; m_z &lt;&lt; <span class="string">")\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 注意：跟第一种情况一样，因为不能访问Vector3d的this指针，所以同样需要传入一个Vector3d对象</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">moveByVector</span><span class="params">(<span class="keyword">const</span> Vector3d &amp;v)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// implement this function as a friend of class Vector3d</span></span><br><span class="line">        m_x += v.m_x;</span><br><span class="line">        m_y += v.m_y;</span><br><span class="line">        m_z += v.m_z;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Point3d p&#123;<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>&#125;;</span><br><span class="line">    Vector3d v&#123;<span class="number">2.0</span>, <span class="number">2.0</span>, <span class="number">-3.0</span>&#125;;</span><br><span class="line"> </span><br><span class="line">    p.<span class="built_in">print</span>();</span><br><span class="line">    p.moveByVector(v);</span><br><span class="line">    p.<span class="built_in">print</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种情况是，<code>Point3d</code>是类<code>Vector3d</code>的友元类，所以<code>Point3d</code>中的所有成员函数都是可以访问<code>Vector3d</code>类的私有成员变量的。</p>
<p>再看第三种情况。还是以<code>Point3d</code>与<code>Vector3d</code>作为例子，不过这种情况下，<code>Point3d</code>中只允许<code>moveByVector</code>函数作为<code>Vector3d</code>的友元函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector3d</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point3d</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> m_x&#123;&#125;;</span><br><span class="line">    <span class="keyword">double</span> m_y&#123;&#125;;</span><br><span class="line">    <span class="keyword">double</span> m_z&#123;&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Point3d(<span class="keyword">double</span> x = <span class="number">0.0</span>, <span class="keyword">double</span> y = <span class="number">0.0</span>, <span class="keyword">double</span> z = <span class="number">0.0</span>)</span><br><span class="line">        : m_x&#123;x&#125;, m_y&#123;y&#125;, m_z&#123;z&#125;</span><br><span class="line">    &#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Point("</span> &lt;&lt; m_x &lt;&lt; <span class="string">" , "</span> &lt;&lt; m_y &lt;&lt; <span class="string">" , "</span> &lt;&lt; m_z &lt;&lt; <span class="string">")\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 方法申明</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">moveByVector</span><span class="params">(<span class="keyword">const</span> Vector3d &amp;v)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector3d</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> m_x&#123;&#125;;</span><br><span class="line">    <span class="keyword">double</span> m_y&#123;&#125;;</span><br><span class="line">    <span class="keyword">double</span> m_z&#123;&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Vector3d(<span class="keyword">double</span> x = <span class="number">0.0</span>, <span class="keyword">double</span> y = <span class="number">0.0</span>, <span class="keyword">double</span> z = <span class="number">0.0</span>)</span><br><span class="line">        : m_x&#123;x&#125;, m_y&#123;y&#125;, m_z&#123;z&#125;</span><br><span class="line">    &#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Vector("</span> &lt;&lt; m_x &lt;&lt; <span class="string">" , "</span> &lt;&lt; m_y &lt;&lt; <span class="string">" , "</span> &lt;&lt; m_z &lt;&lt; <span class="string">")\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 申明 moveByVector 是本类的友元函数</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">Point3d::moveByVector</span><span class="params">(<span class="keyword">const</span> Vector3d &amp;v)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义，注意顺序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Point3d::moveByVector</span><span class="params">(<span class="keyword">const</span> Vector3d &amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// implement this function as a friend of class Vector3d</span></span><br><span class="line">    m_x += v.m_x;</span><br><span class="line">    m_y += v.m_y;</span><br><span class="line">    m_z += v.m_z;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Point3d p&#123;<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>&#125;;</span><br><span class="line">    Vector3d v&#123;<span class="number">2.0</span>, <span class="number">2.0</span>, <span class="number">-3.0</span>&#125;;</span><br><span class="line"> </span><br><span class="line">    p.<span class="built_in">print</span>();</span><br><span class="line">    p.moveByVector(v);</span><br><span class="line">    p.<span class="built_in">print</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种情况下，主要上要考虑到各个类之间的顺序。顺序为:申明要访问的类–&gt;定义包含友元函数的类(其中友元函数只能申明，不能定义在类内)–&gt;定义要访问的类(其中用friend申明友元函数)–&gt;定义友元函数。</p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>linux虚拟内存</title>
    <url>/2021/02/27/linux-virtual-memory/</url>
    <content><![CDATA[<p>linux的虚拟内存空间是通过CPU中的MMU来实现的。要使得MMU工作，操作系统必须填充页表的数据结构，剩下的部分交给cpu来处理。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>c++成员初始化列表</title>
    <url>/2021/02/25/cpp-initialize-list/</url>
    <content><![CDATA[<p>c++成员初始化列表，用于c++构造函数中。c++成员初始化列表的语法为：在构造函数名小括号之后，大括号之前，在小括号之后使用’:’，然后是’成员变量{初始化值}’。看如下例子:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdint&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RGBA</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">uint_fast8_t</span> m_red;</span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">uint_fast8_t</span> m_green;</span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">uint_fast8_t</span> m_blue;</span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">uint_fast8_t</span> m_alpha;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    RGBA(<span class="built_in">std</span>::<span class="keyword">uint_fast8_t</span> red=<span class="number">0</span>, <span class="built_in">std</span>::<span class="keyword">uint_fast8_t</span> green=<span class="number">0</span>, <span class="built_in">std</span>::<span class="keyword">uint_fast8_t</span> blue=<span class="number">0</span>, <span class="built_in">std</span>::<span class="keyword">uint_fast8_t</span> alpha=<span class="number">255</span>)</span><br><span class="line">        : m_red&#123;red&#125;, m_green&#123;green&#125;, m_blue&#123;blue&#125;, m_alpha&#123;alpha&#125;</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"r="</span> &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(m_red) &lt;&lt; <span class="string">" g="</span> &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(m_green) &lt;&lt; <span class="string">" b="</span> &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(m_blue) &lt;&lt; <span class="string">" a="</span> &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(m_alpha) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    RGBA teal&#123; <span class="number">0</span>, <span class="number">127</span>, <span class="number">127</span> &#125;;</span><br><span class="line">    teal.<span class="built_in">print</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="best-practice"><a href="#best-practice" class="headerlink" title="best practice"></a>best practice</h5><p>在编写构造函数时，应该使用成员初始化列表。在初始话时，应该将成员初始化列表中的成员名顺序保持跟成员申明的顺序一致。</p>
<h5 id="委派构造函数"><a href="#委派构造函数" class="headerlink" title="委派构造函数"></a>委派构造函数</h5><p>如果在一个类中有多个构造函数，有可能需要在一个构造函数中调用另一个构造函数，这种情况下，不能直接在构造函数体中调用另一给构造函数，应该通过初始化列表来调用。看下面的例子:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Foo()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// code to do A</span></span><br><span class="line">    &#125;</span><br><span class="line">    Foo(<span class="keyword">int</span> value)</span><br><span class="line">    &#123;</span><br><span class="line">        Foo();</span><br><span class="line">        <span class="comment">// codo to do B</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面的构造函数<code>Foo(int value)</code>中调用了<code>Foo()</code>构造函数，但是这样并不生效，在函数体中调用第一个构造函数只会重新实例化一个Foo类。正确的做法应该如下:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_id&#123;&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> m_name&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Employee(<span class="keyword">int</span> id=<span class="number">0</span>, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;name=<span class="string">""</span>):</span><br><span class="line">        m_id&#123;id&#125;, m_name&#123;name&#125;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Employee "</span> &lt;&lt; m_name &lt;&lt; <span class="string">" created.\n"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Employee(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;name) : Employee&#123;<span class="number">0</span>, name&#125;</span><br><span class="line">    &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>从上面的例子可以看出，第二个<code>Employee</code>构造函数调用了第一个构造函数。</p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>c++中this指针</title>
    <url>/2021/02/26/cpp-this/</url>
    <content><![CDATA[<p>在c++中，当对象在调用成员函数时，该对象的成员函数是如何分辨出该操作哪个对象的成员的变量的呢？看下面的例子。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Simple</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_id;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Simple(<span class="keyword">int</span> id) : m_id&#123;id&#125;</span><br><span class="line">    &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setID</span><span class="params">(<span class="keyword">int</span> id)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getID</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> m_id;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Simple simple&#123;<span class="number">1</span>&#125;;</span><br><span class="line">    simple.setID(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; simple.getID() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的例子中的simple.setID(2)是如何知道要设置的是simple对象的m_id成员变量的值的呢？这个就是<code>this</code>指针的作用的了。</p>
<a id="more"></a>

<h5 id="c-编译器对非静态成员函数的处理"><a href="#c-编译器对非静态成员函数的处理" class="headerlink" title="c++编译器对非静态成员函数的处理"></a>c++编译器对非静态成员函数的处理</h5><p>c++编译器在处理非静态成员函数时，如<code>simple.setID(2)</code>，会转换成<code>setID(&amp;simple, 2)</code>，也就是说，非静态成员函数，在编译的时候，编译器会为该函数添加一个参数，放在第一个参数的位置。这个参数的名字就是<code>this</code>,它的类型为指向该类的一个常量指针变量。所以下面的函数:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setID</span><span class="params">(<span class="keyword">int</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_id = id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>会被编译器转换成：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setID</span><span class="params">(Simple* <span class="keyword">const</span> <span class="keyword">this</span>, <span class="keyword">int</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_id = id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，当调用成员函数时，就能够正确的操作成员变量了。<br>总结:  </p>
<ol>
<li>当调用<code>simple.setID(2)</code>时，实际调用的是setID(&amp;simple, 2);</li>
<li>在setID函数内部，<code>this</code>指针保存了simple对象的地址。</li>
<li>在setID函数内的所有成员变量在处理的时候都会加上<code>this-&gt;</code>操作符。所以<code>m_id = id</code>在实际执行的时候，是在执行<code>this-&gt;m_id = id</code>。</li>
</ol>
<p>#####this指针的实际使用<br>this指针实际使用的时候一般是将this指针指向的对象返回，经常用于运算符重载中。看下面的例子:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Calc</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_value&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Calc&amp; <span class="title">add</span><span class="params">(<span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_value += value;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Calc&amp; <span class="title">sub</span><span class="params">(<span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_value -= value;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Calc&amp; <span class="title">mult</span><span class="params">(<span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_value *= value;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> m_value;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Calc calc&#123;&#125;;</span><br><span class="line">    calc.add(<span class="number">3</span>).mult(<span class="number">5</span>).sub(<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"3 * 5 - 9 = "</span> &lt;&lt; calc.getValue() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
</search>
